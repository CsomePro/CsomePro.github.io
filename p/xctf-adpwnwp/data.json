{"title":"[9th XCTF Final AwD Pwn] 出题心得","date":"2025-11-02T17:55:00.000Z","toc":true,"source":"_posts/xctf-adpwnwp.md","raw":"---\ntitle: \"[9th XCTF Final AwD Pwn] 出题心得\"\ndate: 2025-11-03 01:55:00\ntoc: true\ncomments: true\ntags: \n  - CTF\n  - Pwn\n  - wp\n  - XCTF\n---\n\n# 9th XCTF Final AwD Pwn 出题心得\n\n## 前言\n\n有幸收到Crazyman的邀请，参与了9th XCTF Final AwD赛的赛题。\n\n今年XCTF Final的赛制进行了很大的创新，除了传统的解题赛之外，还包含了RealWorld、IoT、AwD，其中AwD独占一天8.5h。对于AwD的赛制规则，今年也有大幅的改动。之前国内赛的AwD多数以AwDplus为主，少数是基于选手SSH维护服务的经典AwD，而今年的XCTF Final AwD赛制是既不会像经典AwD那样那么混乱导致选手体验失衡，也不会像AwDplus过于的束缚选手的想象力。同时XCTF Final的AwD引入了类似DEFCON的Patch和流量延迟公开的机制，使得选手对于赛制的策略需要有较大的变化。\n\nAwD的记分也有比较大的改动，为按轮次记分，被攻陷扣除30%当前得分，并平分给成功攻陷的队伍。也就是如果一支队伍一道题目很强，获得了几万分，但是如果修补存在漏洞，会导致其他队伍直接获得这几万份的30%，一举翻盘。\n\n当我收到这个赛制信息的时候是7月份，我十分喜爱这个创新，并打算构思一些有意思的题目，虽然延期了（我也10月份才动工）。最后为了适应Patch和流量延迟公开的机制以及赛题记分的机制，我贡献了两道题目somehash和someheap。\n\n## somehash\n\n### 设计构思\n\n本题是先构思的一道题目，最开始的设计是本题需要结合Crypto、Reverse的一道Pwn题。并且也不打算加入传统Pwn题打ROP、HOOK、IO FILE等技术，所以本题的核心是信息泄漏，攻击者需要思考如何从靶机中获得Admin token。\n\n首先，我设计了一个Challenge-Response挑战应答模式的登陆认证，如果认证成功，那么即可获得Shell（使用挑战应答模式可以避免其他队伍批量尝试token的时候流量造成的泄漏，以及这里也可以埋入一个漏洞点）。\n\n之后我结合Patch延迟公开的机制，设计了一个外部文件生成Admin token的过程，此过程设计上需要加入一点点的逆向，并且此处默认config是空，以及如果config校验失败也会导致Admin token为默认，其他队伍可以通过默认Admin token获得flag。\n\n由于Patch会延迟公布，所以这里要求选手，编写自动化的config生成，并且每回合都需要提交新的Patch；同理攻击者也需要编写自动化下载Patch分析config生成admin token去批量攻击其他队伍。（这同时也使得抄Patch也容易导致admin token泄漏）\n\n那么接下来，继续围绕admin token设计其他的漏洞。\n\n### 漏洞清单\n\n题目中包含两个直接漏洞\n\n1. 默认admin token以及Patch延迟公开导致admin token泄漏\n2. strncpy拼接并由printf %s泄漏admin token\n\n以及四个非直接的漏洞，因为涉及session中间量，所以分成两个过程，分别是 过程A和过程B\n\n过程A漏洞\n\n1. 弱随机数种子 srand(time(0))\n2. 利用生日攻击MD5，得到1最少的user token，通过统计泄漏的session恢复admin token\n\n过程B漏洞\n\n1. login逻辑中，scanf未初始化导致泄漏session\n2. show heap逻辑中，由于使用了strncpy方法导致泄漏session\n\n过程A中选择一种方法，过程B中选择一种方法，可以组合出4种攻击方法\n\n### 修补\n\n这道题目依旧保留了AwDplus类似的patch elf，并check修改的字符是否在给定的允许patch范围的白名单中，本题对于ELF的patch校验十分严格，只允许4个位置，但是对于config并没有校验\n\n```python\nWHITE_LIST = [\n    Allowed(offset=0x14F1, length=0x19),  # 修改 srand(time(0))，增强随机数\n    Allowed(offset=0x2057, length=5),     # 防止login入口泄漏session\n    Allowed(offset=0x22cd, length=5),     # 防止login_user拼接泄漏admin token\n    Allowed(offset=0x2b9c, length=5),     # 防止堆操作泄漏session\n]\n```\n\n#### 直接漏洞1\n\n默认config文件是空，`generate_token`过程中`memset(token, 0x41, 0x10);`将token初始化为0x41，config文件未反序列化成功，token仍将保持为0x41。\n\n修补建议，需要逆向config文件反序列化过程，编写自动化生成config文件与提交patch的脚本。\n\n##### config生成\n\n本题config生成是一个划分问题，题目要求将下面这个文本（随便找的0w0），划分成若干份，并按照`size|nonce|content`为一个block的方式写入文件。题目还要求block的顺序必须与与其自身的MD5顺序相同，所以需要爆破多次尝试nonce，直到符合条件（这个爆破复杂度并不大）。随后程序会根据划分的每一个block的size，拼接，计算MD5，得到admin token。\n\n```plaintext\nThere, my blessing with thee. And these few precepts in thy memory Look thou character. Give thy thoughts no tongue, Nor any unproportioned thought his act. Be thou familiar but by no means vulgar. Those friends thou hast, and their adoption tried, Grapple them unto thy soul with hoops of steel, But do not dull thy palm with entertainment Of each new-hatched, unfledged comrade. Beware Of entrance to a quarrel, but being in, Bear 't that th' opposed may beware of thee. Give every man thy ear but few thy voice. Take each man's censure but reserve thy judgment. Costly thy habit as thy purse can buy, But not expressed in fancy-rich, not gaudy, For the apparel oft proclaims the man, And they in France of the best rank and station Are of a most select and generous chief in that. Neither a borrower nor a lender be, For loan oft loses both itself and friend, And borrowing dulls the edge of husbandry. This above all: to thine own self be true, And it must follow, as the night the day, Thou canst not then be false to any man. Farewell. My blessing season this in thee.\n\n```\n\n所以选手逆向理解这个逻辑之后，给大模型应该很快就能写出自动化生成的脚本。\n\n#### 直接漏洞2\n\n在`login_user`逻辑中`strncpy(user_username, username, 0x10);`会填满`user_username`导致后续`help`方法泄漏admin token。\n\n修补建议，patch为`strncpy(user_username, username, 0xf);`\n\n#### 间接漏洞-过程A-1\n\n弱随机数种子来自的`time(0);`，可能组合后续的leak session导致admin token泄漏。\n\n修补建议，使用其他数值替换srand参数，例如基于PIE的随机数种子等。\n\n#### 间接漏洞-过程A-2\n\n在`login_user`过程中，`xor_chars(user_token, tmp, 0x10);`存在生日攻击可能，但就算不xor也能构造出1多0少的md5，之后通过泄漏session，即可通过纵向统计session中相同位置的bit的0和1的数量即可恢复admin token。\n\n![111.drawio](xctf-adpwnwp/111.drawio.png)\n\n此漏洞为逻辑漏洞，无法修补，建议修补其他泄漏session的过程\n\n#### 间接漏洞-过程B-1\n\n在login函数中，`scanf(\"%lx\", &chall->session.a);`可能导致`chall->session.a`未初始化问题，导致堆上数据泄露，从而可以组合过程A，泄漏admin token。\n\n修补建议，将生成challenge的函数rand_bytes参数增加`rand_bytes((unsigned char*)chall->challenge, 0x20);`\n\n#### 间接漏洞-过程B-2\n\n在view_note的函数中，`strncpy(tmp, buffer[idx], sizes[idx]);`此处使用strncpy拷贝堆上xor后的数据，而堆上数据可能会因为0截断，导致拷贝并不完全，导致tmp数据缺失部分数据，最后进行decrypt的时候泄漏session\n\n修补建议，将`strncpy`替换成`memcpy`即可。\n\n## someheap\n\n本题是在XCTF比赛前一周开始构思的题目，一样需要结合XCTF Final的Patch公开机制和流量公开机制，打算设计一个竞技性很强的题目。本题也是打算设计成比较贴近DEFCON Final题目的类型，让选手体验竞技的刺激。\n\n（其实也是不想写传统的白名单限制允许patch的区域，这种模式有点像是填空题了，所以这道题目设计上不希望选手能patch ELF了）\n\n这道题目核心是一道堆菜单题，并且需要利用好防御方和攻击方的作用。\n\n这道菜单题，包含多个堆原语的操作。\n\n1. Add操作 （分成malloc和calloc）\n2. Free操作 （存在UAF）\n3. Edit操作 （写入长度由攻击方控制，可以overflow）\n4. Show操作 （输出长度由攻击方控制，越界泄漏）\n\n## 防御方\n\n本题设计的难点主要在于防御方。为了能更好的融入题目，这里设计了一个firewall文件，防御方需要编写amd64的机器码，当程序启动的时候，会加载这个firewall文件到内存中，随后在堆操作前后会调用这个文件，进行check（check返回约定是，返回0表示正常，返回非0程序将exit退出）\n\n由于防御方拥有当前进程执行任意代码的能力，所以我需要给防御方增加编写amd64代码的难度。\n\n1. 首先这道题目开启了沙箱，并且firewall不允许包含`0x0f 0x05` syscall/`0x0f 0x34` sysenter/`0xcd 0x80` int 0x80这些会产生系统调用的指令\n\n   ```asm\n   # check if arch is X86_64\n   A = arch\n   A == ARCH_X86_64 ? next : dead\n   A = sys_number\n   A >= 0x40000000 ? dead : next\n   A == open ? ok : next\n   A == read ? ok : next\n   A == write ? ok : next\n   A == close ? ok : next\n   A == brk ? ok : next\n   A == exit ? ok : next\n   A == exit_group ? ok : next\n   A == futex ? ok : next\n   A == getrandom ? ok : next\n   if(A == arch_prctl) goto prctl_test\n   goto dead\n   prctl_test:\n   A = args[0]\n   A == 0x1001 ? ok : next\n   A == 0x1002 ? ok : next\n   A == 0x1003 ? ok : next\n   A == 0x1004 ? ok : next\n   goto dead\n   ok:\n   return ALLOW\n   dead:\n   return KILL\n   \n   ```\n\n2. 为了防止防御者可以通过地址计算，逃逸到bss上，或者libc中，这里需要防止防御者使用代码计算得到bss/libc地址，所以这里采用了强随机地址，使用`/dev/urandom`生成强随机的地址区域，作为firewall代码段、firewall执行的stack空间等。\n\n   ```c\n   dynamic_obj->func =  mmap((void*)((size_t)get_random_addr() & (~0xfff)), 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n   dynamic_obj->stack = mmap((void*)((size_t)get_random_addr() & (~0xfff)), 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n   ```\n\n3. 其次执行firewall的时候需要清空所有寄存器包括xmm寄存器和fs、gs寄存器，但是由于需要记录返回地址，所以我将返回地址记录在了firewall代码段的最后方，此时又需要防止firewall读取到这个地址导致逃逸，所以我设置了firewall代码段`--x`的权限\n\n   ```c\n   mprotect(dynamic_obj->func, 0x1000, PROT_EXEC);\n   ```\n\n4. 为了让firewall程序编程无状态的，所以每次执行的时候都会将firewall执行栈清空\n\n   ```c\n   memset(dynamic_obj->stack, 0, 0x1000);\n   ```\n\n5. 最后为了防止防御方很简单的通过idx信息进行记录对应的堆状态，这里允许攻击者设置srand种子，并且firewall获得idx参数时解密前的参数，真实idx是`encrypt(idx) % 0x100` (这里为了rand()数据在stack上残留，故意开了O2)\n\n   ```c\n   __attribute__((optimize(\"O2\"))) size_t encrypt(size_t val) {\n       register size_t rand_val = (size_t)rand();\n       return val + rand_val;\n   }\n   ```\n\n6. 最后防御方还有一个最困难的一点，防御方无法判断当前被调用的地方是在add/free/show/edit哪一个功能中，因为每一个传入的参数都是`(idx, size, heap_addr)` \n\n这些大概就是防御方的限制，可以看到，防御方只能通过一些堆的状态进行判断。\n\n比较好的是，进行校验的位置都是堆地址申请出来之后，释放之前这个区间进行校验，也就是说，堆地址正常生命周期处在被使用的时候会进入check，所以最简单的校验是通过`prev_inuse`位置来判断，当前堆地址是否存在UAF问题。（当然这也只能解决unsortedbins、smallbins、largebins这些相关的UAF，并不能解决fastbins、tcachebins的UAF问题）\n\n其次，为了解决Overflow的问题，也可以通过获取堆的size，进行判断。这两个校验应该是比较容易想到的。\n\n**如何解决tcachebins的UAF问题？**\n\n我也没想到很完备的方案能解决这个问题，但是可以稍微限制的是，可以通过解析`tcache_entry`结构体，来校验是否存在tcache UAF问题。\n\n```c\n#include <stddef.h>\n\n# define TCACHE_MAX_BINS\t\t64\n\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  size_t key;\n} tcache_entry;\n\ntypedef struct tcache_perthread_struct\n{\n  unsigned short counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n\nsize_t check(size_t a, size_t b, size_t addr) {\n    size_t base = addr & (~0xfff);\n\n    while (1) {\n        size_t* p = (size_t*)(base + 0x8);\n        if(*p != 0x291) {\n            base -= 0x1000;\n            continue;\n        }\n        break;\n    }\n\n    tcache_perthread_struct* tcache = (tcache_perthread_struct*)(base + 0x10);\n    size_t size = *(size_t*)(addr - 0x8);\n\n    if(size > 0x410) {\n        return 0;\n    }\n\n    size_t tc_idx = (size - 0x20) >> 4;\n    size_t tc_cnt = tcache->counts[tc_idx];\n    int cnt = 0;\n    tcache_entry *tmp;\n    for (tmp = tcache->entries[tc_idx];\n         tmp;\n         tmp = REVEAL_PTR (tmp->next), ++cnt)\n    {\n        if (cnt >= tc_cnt) return 0;\n            if ((size_t)tmp == addr) return 1;\n          }\n    return 0;\n}\n```\n\n当然这个检查也有机会绕过，通过在页对齐的地方布置一个伪造的`tcache_entry`即可。\n\n**后门？**\n\n在比赛的开始也给了提示，这道题目后门是允许的预期。虽然我在后台看日志的时候没找到后门的样本，如果有遗漏，欢迎大家评论或者提交issue！\n\n这里给一个预期中的后门设计方法。\n\n由于这道题目firewall的限制非常大，在一个构造的沙箱中，我们可以通过一些特征的size或者heap内容特定的字符串，或者是heap特定的size等等，这些进行校验是否进入后门分支。其次，由于需要逃逸沙箱，所以需要保证堆数据中包含libc地址，比如说main_arena地址，之后firewall就可以从main_arena逃逸到_environ，逃逸到stack上，stack上包含程序的基地址，从而计算出bss地址，最后即可得到`dynamic_obj`中所有的信息，其中包含了win函数的地址，直接jmp到win，即可获得flag。\n\n```c\nunsigned char win[] = { 0x48, 0xb8, 0x2f, 0x66, 0x6c, 0x61, 0x67, 0x00, 0x00, 0x00, 0x50, 0x48, 0x89, 0xe7, 0x48, 0xc7, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc2, 0x40, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc2, 0x40, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x0f, 0x05 };\nsize_t win_addr = (size_t)get_random_addr();\ndynamic_obj->win =  mmap((void*)(win_addr & (~0xfff)), 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\nsize_t win_addr_page = (size_t)dynamic_obj->win;\ndynamic_obj->win = (void*)(((size_t)dynamic_obj->win) + (win_addr & 0xfff));\nmemcpy(dynamic_obj->win, win, sizeof(win));\nmprotect((void*)win_addr_page, 0x2000, PROT_EXEC);\n```\n\n## 进攻方\n\n题目对于进攻方的交互上没有特殊的设计，就是常规的交互。\n\n由于规则限制，所有选手需要至少提交一次flag，才能patch此题目，所以大家需要攻击默认状态下的题目，而默认状态下firewall为空，也就是简单的tcache UAF利用打IO FILE，比较基础。\n\n由于防御方依旧可以通过一些技巧，特定的限制进攻方的利用，导致利用难度剧增，本题设计了一个Level机制。\n\n本题目分成6个level，level根据防御方firewall长度而变化\n\n1. 当firewall长度<=5 （初始情况） \n    - 攻击方没有降低难度\n\n2. 当firewall长度<=30 (基本情况)\n    - 攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr\n\n3. 当firewall长度<=50 （基本上能检查size长度，阻止溢出了）\n    - 攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr\n    - 并且攻击方只需要在这个随机可读可写地址Addr写入win函数地址即可拿到flag\n\n4. 当firewall长度<=80 （此时能做一点简易的uaf检查）\n    - 攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr\n    - 并且攻击方只需要在这个随机可读可写地址Addr任何非0的数值即可拿到flag\n\n5. 当firewall长度<=120 （此时基本上能做较强的uaf检查，以及可以做一些size检查）\n    - 攻击方能直接获得heap地址、libc地址\n    - 并且攻击方只需要 堆上的一个位置写入win函数地址 即可拿到flag\n\n6. 当firewall长度<=1000 （最后所有情况）\n    - 攻击方能直接获得heap地址、libc地址\n    - 并且攻击方只需要 堆上的一个位置写入非0 即可拿到flag\n\n```c\nvoid info() {\n    printf(\"win: %p\\n\", dynamic_obj->win);\n    if(dynamic_obj->level.info_leak) {\n        char *p = malloc(0x500);\n        printf(\"printf: %p\\n\", printf);\n        printf(\"heap: %p\\n\", p);\n        free(p);\n    }\n    if(dynamic_obj->level.in_heap == 0) {\n        printf(\"target: %p\\n\", dynamic_obj->near_heap_addr);\n    }\n}\n\nvoid win_flag() {\n    if(dynamic_obj->level.near_heap == 1) {\n        if((*((size_t*)dynamic_obj->near_heap_addr)) == (size_t)dynamic_obj->win) dynamic_obj->win();\n    } else if(dynamic_obj->level.near_heap == 2) {\n        if(*((size_t*)(dynamic_obj->near_heap_addr))) dynamic_obj->win();\n    } else {\n        _IO_flush_all();\n        ___exit(0);\n    }\n}\n```\n\n所以进攻方，可以根据当前题目的level，进行针对性的编写exp即可。\n\n# 后记\n\n本题代码将在 https://github.com/CsomePro/9th-XCTF-Final-ADPWN 开源，欢迎预期或非预期提交issue讨论。\n\n","slug":"xctf-adpwnwp","published":true,"updated":"2025-11-02T18:00:21.384Z","_id":"cuidmfL3Hc6JsvO1v3kjVFc1d","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"9th-XCTF-Final-AwD-Pwn-出题心得\"><a href=\"#9th-XCTF-Final-AwD-Pwn-出题心得\" class=\"headerlink\" title=\"9th XCTF Final AwD Pwn 出题心得\"></a>9th XCTF Final AwD Pwn 出题心得</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有幸收到Crazyman的邀请，参与了9th XCTF Final AwD赛的赛题。</p>\n<p>今年XCTF Final的赛制进行了很大的创新，除了传统的解题赛之外，还包含了RealWorld、IoT、AwD，其中AwD独占一天8.5h。对于AwD的赛制规则，今年也有大幅的改动。之前国内赛的AwD多数以AwDplus为主，少数是基于选手SSH维护服务的经典AwD，而今年的XCTF Final AwD赛制是既不会像经典AwD那样那么混乱导致选手体验失衡，也不会像AwDplus过于的束缚选手的想象力。同时XCTF Final的AwD引入了类似DEFCON的Patch和流量延迟公开的机制，使得选手对于赛制的策略需要有较大的变化。</p>\n<p>AwD的记分也有比较大的改动，为按轮次记分，被攻陷扣除30%当前得分，并平分给成功攻陷的队伍。也就是如果一支队伍一道题目很强，获得了几万分，但是如果修补存在漏洞，会导致其他队伍直接获得这几万份的30%，一举翻盘。</p>\n<p>当我收到这个赛制信息的时候是7月份，我十分喜爱这个创新，并打算构思一些有意思的题目，虽然延期了（我也10月份才动工）。最后为了适应Patch和流量延迟公开的机制以及赛题记分的机制，我贡献了两道题目somehash和someheap。</p>\n<h2 id=\"somehash\"><a href=\"#somehash\" class=\"headerlink\" title=\"somehash\"></a>somehash</h2><h3 id=\"设计构思\"><a href=\"#设计构思\" class=\"headerlink\" title=\"设计构思\"></a>设计构思</h3><p>本题是先构思的一道题目，最开始的设计是本题需要结合Crypto、Reverse的一道Pwn题。并且也不打算加入传统Pwn题打ROP、HOOK、IO FILE等技术，所以本题的核心是信息泄漏，攻击者需要思考如何从靶机中获得Admin token。</p>\n<p>首先，我设计了一个Challenge-Response挑战应答模式的登陆认证，如果认证成功，那么即可获得Shell（使用挑战应答模式可以避免其他队伍批量尝试token的时候流量造成的泄漏，以及这里也可以埋入一个漏洞点）。</p>\n<p>之后我结合Patch延迟公开的机制，设计了一个外部文件生成Admin token的过程，此过程设计上需要加入一点点的逆向，并且此处默认config是空，以及如果config校验失败也会导致Admin token为默认，其他队伍可以通过默认Admin token获得flag。</p>\n<p>由于Patch会延迟公布，所以这里要求选手，编写自动化的config生成，并且每回合都需要提交新的Patch；同理攻击者也需要编写自动化下载Patch分析config生成admin token去批量攻击其他队伍。（这同时也使得抄Patch也容易导致admin token泄漏）</p>\n<p>那么接下来，继续围绕admin token设计其他的漏洞。</p>\n<h3 id=\"漏洞清单\"><a href=\"#漏洞清单\" class=\"headerlink\" title=\"漏洞清单\"></a>漏洞清单</h3><p>题目中包含两个直接漏洞</p>\n<ol>\n<li>默认admin token以及Patch延迟公开导致admin token泄漏</li>\n<li>strncpy拼接并由printf %s泄漏admin token</li>\n</ol>\n<p>以及四个非直接的漏洞，因为涉及session中间量，所以分成两个过程，分别是 过程A和过程B</p>\n<p>过程A漏洞</p>\n<ol>\n<li>弱随机数种子 srand(time(0))</li>\n<li>利用生日攻击MD5，得到1最少的user token，通过统计泄漏的session恢复admin token</li>\n</ol>\n<p>过程B漏洞</p>\n<ol>\n<li>login逻辑中，scanf未初始化导致泄漏session</li>\n<li>show heap逻辑中，由于使用了strncpy方法导致泄漏session</li>\n</ol>\n<p>过程A中选择一种方法，过程B中选择一种方法，可以组合出4种攻击方法</p>\n<h3 id=\"修补\"><a href=\"#修补\" class=\"headerlink\" title=\"修补\"></a>修补</h3><p>这道题目依旧保留了AwDplus类似的patch elf，并check修改的字符是否在给定的允许patch范围的白名单中，本题对于ELF的patch校验十分严格，只允许4个位置，但是对于config并没有校验</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHITE_LIST = [</span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x14F1</span>, length=<span class=\"number\">0x19</span>),  <span class=\"comment\"># 修改 srand(time(0))，增强随机数</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x2057</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止login入口泄漏session</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x22cd</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止login_user拼接泄漏admin token</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x2b9c</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止堆操作泄漏session</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"直接漏洞1\"><a href=\"#直接漏洞1\" class=\"headerlink\" title=\"直接漏洞1\"></a>直接漏洞1</h4><p>默认config文件是空，<code>generate_token</code>过程中<code>memset(token, 0x41, 0x10);</code>将token初始化为0x41，config文件未反序列化成功，token仍将保持为0x41。</p>\n<p>修补建议，需要逆向config文件反序列化过程，编写自动化生成config文件与提交patch的脚本。</p>\n<h5 id=\"config生成\"><a href=\"#config生成\" class=\"headerlink\" title=\"config生成\"></a>config生成</h5><p>本题config生成是一个划分问题，题目要求将下面这个文本（随便找的0w0），划分成若干份，并按照<code>size|nonce|content</code>为一个block的方式写入文件。题目还要求block的顺序必须与与其自身的MD5顺序相同，所以需要爆破多次尝试nonce，直到符合条件（这个爆破复杂度并不大）。随后程序会根据划分的每一个block的size，拼接，计算MD5，得到admin token。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There, my blessing with thee. And these few precepts in thy memory Look thou character. Give thy thoughts no tongue, Nor any unproportioned thought his act. Be thou familiar but by no means vulgar. Those friends thou hast, and their adoption tried, Grapple them unto thy soul with hoops of steel, But do not dull thy palm with entertainment Of each new-hatched, unfledged comrade. Beware Of entrance to a quarrel, but being in, Bear &#x27;t that th&#x27; opposed may beware of thee. Give every man thy ear but few thy voice. Take each man&#x27;s censure but reserve thy judgment. Costly thy habit as thy purse can buy, But not expressed in fancy-rich, not gaudy, For the apparel oft proclaims the man, And they in France of the best rank and station Are of a most select and generous chief in that. Neither a borrower nor a lender be, For loan oft loses both itself and friend, And borrowing dulls the edge of husbandry. This above all: to thine own self be true, And it must follow, as the night the day, Thou canst not then be false to any man. Farewell. My blessing season this in thee.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>所以选手逆向理解这个逻辑之后，给大模型应该很快就能写出自动化生成的脚本。</p>\n<h4 id=\"直接漏洞2\"><a href=\"#直接漏洞2\" class=\"headerlink\" title=\"直接漏洞2\"></a>直接漏洞2</h4><p>在<code>login_user</code>逻辑中<code>strncpy(user_username, username, 0x10);</code>会填满<code>user_username</code>导致后续<code>help</code>方法泄漏admin token。</p>\n<p>修补建议，patch为<code>strncpy(user_username, username, 0xf);</code></p>\n<h4 id=\"间接漏洞-过程A-1\"><a href=\"#间接漏洞-过程A-1\" class=\"headerlink\" title=\"间接漏洞-过程A-1\"></a>间接漏洞-过程A-1</h4><p>弱随机数种子来自的<code>time(0);</code>，可能组合后续的leak session导致admin token泄漏。</p>\n<p>修补建议，使用其他数值替换srand参数，例如基于PIE的随机数种子等。</p>\n<h4 id=\"间接漏洞-过程A-2\"><a href=\"#间接漏洞-过程A-2\" class=\"headerlink\" title=\"间接漏洞-过程A-2\"></a>间接漏洞-过程A-2</h4><p>在<code>login_user</code>过程中，<code>xor_chars(user_token, tmp, 0x10);</code>存在生日攻击可能，但就算不xor也能构造出1多0少的md5，之后通过泄漏session，即可通过纵向统计session中相同位置的bit的0和1的数量即可恢复admin token。</p>\n<p><img src=\"/p/xctf-adpwnwp/111.drawio.png\" alt=\"111.drawio\"></p>\n<p>此漏洞为逻辑漏洞，无法修补，建议修补其他泄漏session的过程</p>\n<h4 id=\"间接漏洞-过程B-1\"><a href=\"#间接漏洞-过程B-1\" class=\"headerlink\" title=\"间接漏洞-过程B-1\"></a>间接漏洞-过程B-1</h4><p>在login函数中，<code>scanf(&quot;%lx&quot;, &amp;chall-&gt;session.a);</code>可能导致<code>chall-&gt;session.a</code>未初始化问题，导致堆上数据泄露，从而可以组合过程A，泄漏admin token。</p>\n<p>修补建议，将生成challenge的函数rand_bytes参数增加<code>rand_bytes((unsigned char*)chall-&gt;challenge, 0x20);</code></p>\n<h4 id=\"间接漏洞-过程B-2\"><a href=\"#间接漏洞-过程B-2\" class=\"headerlink\" title=\"间接漏洞-过程B-2\"></a>间接漏洞-过程B-2</h4><p>在view_note的函数中，<code>strncpy(tmp, buffer[idx], sizes[idx]);</code>此处使用strncpy拷贝堆上xor后的数据，而堆上数据可能会因为0截断，导致拷贝并不完全，导致tmp数据缺失部分数据，最后进行decrypt的时候泄漏session</p>\n<p>修补建议，将<code>strncpy</code>替换成<code>memcpy</code>即可。</p>\n<h2 id=\"someheap\"><a href=\"#someheap\" class=\"headerlink\" title=\"someheap\"></a>someheap</h2><p>本题是在XCTF比赛前一周开始构思的题目，一样需要结合XCTF Final的Patch公开机制和流量公开机制，打算设计一个竞技性很强的题目。本题也是打算设计成比较贴近DEFCON Final题目的类型，让选手体验竞技的刺激。</p>\n<p>（其实也是不想写传统的白名单限制允许patch的区域，这种模式有点像是填空题了，所以这道题目设计上不希望选手能patch ELF了）</p>\n<p>这道题目核心是一道堆菜单题，并且需要利用好防御方和攻击方的作用。</p>\n<p>这道菜单题，包含多个堆原语的操作。</p>\n<ol>\n<li>Add操作 （分成malloc和calloc）</li>\n<li>Free操作 （存在UAF）</li>\n<li>Edit操作 （写入长度由攻击方控制，可以overflow）</li>\n<li>Show操作 （输出长度由攻击方控制，越界泄漏）</li>\n</ol>\n<h2 id=\"防御方\"><a href=\"#防御方\" class=\"headerlink\" title=\"防御方\"></a>防御方</h2><p>本题设计的难点主要在于防御方。为了能更好的融入题目，这里设计了一个firewall文件，防御方需要编写amd64的机器码，当程序启动的时候，会加载这个firewall文件到内存中，随后在堆操作前后会调用这个文件，进行check（check返回约定是，返回0表示正常，返回非0程序将exit退出）</p>\n<p>由于防御方拥有当前进程执行任意代码的能力，所以我需要给防御方增加编写amd64代码的难度。</p>\n<ol>\n<li><p>首先这道题目开启了沙箱，并且firewall不允许包含<code>0x0f 0x05</code> syscall&#x2F;<code>0x0f 0x34</code> sysenter&#x2F;<code>0xcd 0x80</code> int 0x80这些会产生系统调用的指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># check if arch is X86_64</span><br><span class=\"line\">A = arch</span><br><span class=\"line\">A == ARCH_X86_64 ? next : dead</span><br><span class=\"line\">A = sys_number</span><br><span class=\"line\">A &gt;= 0x40000000 ? dead : next</span><br><span class=\"line\">A == open ? ok : next</span><br><span class=\"line\">A == read ? ok : next</span><br><span class=\"line\">A == write ? ok : next</span><br><span class=\"line\">A == close ? ok : next</span><br><span class=\"line\">A == brk ? ok : next</span><br><span class=\"line\">A == exit ? ok : next</span><br><span class=\"line\">A == exit_group ? ok : next</span><br><span class=\"line\">A == futex ? ok : next</span><br><span class=\"line\">A == getrandom ? ok : next</span><br><span class=\"line\">if(A == arch_prctl) goto prctl_test</span><br><span class=\"line\">goto dead</span><br><span class=\"line\">prctl_test:</span><br><span class=\"line\">A = args[0]</span><br><span class=\"line\">A == 0x1001 ? ok : next</span><br><span class=\"line\">A == 0x1002 ? ok : next</span><br><span class=\"line\">A == 0x1003 ? ok : next</span><br><span class=\"line\">A == 0x1004 ? ok : next</span><br><span class=\"line\">goto dead</span><br><span class=\"line\">ok:</span><br><span class=\"line\">return ALLOW</span><br><span class=\"line\">dead:</span><br><span class=\"line\">return KILL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了防止防御者可以通过地址计算，逃逸到bss上，或者libc中，这里需要防止防御者使用代码计算得到bss&#x2F;libc地址，所以这里采用了强随机地址，使用<code>/dev/urandom</code>生成强随机的地址区域，作为firewall代码段、firewall执行的stack空间等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dynamic_obj-&gt;func =  mmap((<span class=\"type\">void</span>*)((<span class=\"type\">size_t</span>)get_random_addr() &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">dynamic_obj-&gt;<span class=\"built_in\">stack</span> = mmap((<span class=\"type\">void</span>*)((<span class=\"type\">size_t</span>)get_random_addr() &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其次执行firewall的时候需要清空所有寄存器包括xmm寄存器和fs、gs寄存器，但是由于需要记录返回地址，所以我将返回地址记录在了firewall代码段的最后方，此时又需要防止firewall读取到这个地址导致逃逸，所以我设置了firewall代码段<code>--x</code>的权限</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect(dynamic_obj-&gt;func, <span class=\"number\">0x1000</span>, PROT_EXEC);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了让firewall程序编程无状态的，所以每次执行的时候都会将firewall执行栈清空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memset</span>(dynamic_obj-&gt;<span class=\"built_in\">stack</span>, <span class=\"number\">0</span>, <span class=\"number\">0x1000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后为了防止防御方很简单的通过idx信息进行记录对应的堆状态，这里允许攻击者设置srand种子，并且firewall获得idx参数时解密前的参数，真实idx是<code>encrypt(idx) % 0x100</code> (这里为了rand()数据在stack上残留，故意开了O2)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__attribute__((optimize(<span class=\"string\">&quot;O2&quot;</span>))) <span class=\"type\">size_t</span> <span class=\"title function_\">encrypt</span><span class=\"params\">(<span class=\"type\">size_t</span> val)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">size_t</span> rand_val = (<span class=\"type\">size_t</span>)rand();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val + rand_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后防御方还有一个最困难的一点，防御方无法判断当前被调用的地方是在add&#x2F;free&#x2F;show&#x2F;edit哪一个功能中，因为每一个传入的参数都是<code>(idx, size, heap_addr)</code></p>\n</li>\n</ol>\n<p>这些大概就是防御方的限制，可以看到，防御方只能通过一些堆的状态进行判断。</p>\n<p>比较好的是，进行校验的位置都是堆地址申请出来之后，释放之前这个区间进行校验，也就是说，堆地址正常生命周期处在被使用的时候会进入check，所以最简单的校验是通过<code>prev_inuse</code>位置来判断，当前堆地址是否存在UAF问题。（当然这也只能解决unsortedbins、smallbins、largebins这些相关的UAF，并不能解决fastbins、tcachebins的UAF问题）</p>\n<p>其次，为了解决Overflow的问题，也可以通过获取堆的size，进行判断。这两个校验应该是比较容易想到的。</p>\n<p><strong>如何解决tcachebins的UAF问题？</strong></p>\n<p>我也没想到很完备的方案能解决这个问题，但是可以稍微限制的是，可以通过解析<code>tcache_entry</code>结构体，来校验是否存在tcache UAF问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> TCACHE_MAX_BINS\t\t64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_entry</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_entry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* This field exists to detect double frees.  */</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> key;</span><br><span class=\"line\">&#125; tcache_entry;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> counts[TCACHE_MAX_BINS];</span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">size_t</span> a, <span class=\"type\">size_t</span> b, <span class=\"type\">size_t</span> addr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> base = addr &amp; (~<span class=\"number\">0xfff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span>* p = (<span class=\"type\">size_t</span>*)(base + <span class=\"number\">0x8</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*p != <span class=\"number\">0x291</span>) &#123;</span><br><span class=\"line\">            base -= <span class=\"number\">0x1000</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tcache_perthread_struct* tcache = (tcache_perthread_struct*)(base + <span class=\"number\">0x10</span>);</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = *(<span class=\"type\">size_t</span>*)(addr - <span class=\"number\">0x8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size &gt; <span class=\"number\">0x410</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">size_t</span> tc_idx = (size - <span class=\"number\">0x20</span>) &gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> tc_cnt = tcache-&gt;counts[tc_idx];</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tcache_entry *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class=\"line\">         tmp;</span><br><span class=\"line\">         tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt &gt;= tc_cnt) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"type\">size_t</span>)tmp == addr) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这个检查也有机会绕过，通过在页对齐的地方布置一个伪造的<code>tcache_entry</code>即可。</p>\n<p><strong>后门？</strong></p>\n<p>在比赛的开始也给了提示，这道题目后门是允许的预期。虽然我在后台看日志的时候没找到后门的样本，如果有遗漏，欢迎大家评论或者提交issue！</p>\n<p>这里给一个预期中的后门设计方法。</p>\n<p>由于这道题目firewall的限制非常大，在一个构造的沙箱中，我们可以通过一些特征的size或者heap内容特定的字符串，或者是heap特定的size等等，这些进行校验是否进入后门分支。其次，由于需要逃逸沙箱，所以需要保证堆数据中包含libc地址，比如说main_arena地址，之后firewall就可以从main_arena逃逸到_environ，逃逸到stack上，stack上包含程序的基地址，从而计算出bss地址，最后即可得到<code>dynamic_obj</code>中所有的信息，其中包含了win函数的地址，直接jmp到win，即可获得flag。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> win[] = &#123; <span class=\"number\">0x48</span>, <span class=\"number\">0xb8</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x6c</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x67</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x50</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe7</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc6</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x02</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc2</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc2</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x3c</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x31</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">size_t</span> win_addr = (<span class=\"type\">size_t</span>)get_random_addr();</span><br><span class=\"line\">dynamic_obj-&gt;win =  mmap((<span class=\"type\">void</span>*)(win_addr &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">size_t</span> win_addr_page = (<span class=\"type\">size_t</span>)dynamic_obj-&gt;win;</span><br><span class=\"line\">dynamic_obj-&gt;win = (<span class=\"type\">void</span>*)(((<span class=\"type\">size_t</span>)dynamic_obj-&gt;win) + (win_addr &amp; <span class=\"number\">0xfff</span>));</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(dynamic_obj-&gt;win, win, <span class=\"keyword\">sizeof</span>(win));</span><br><span class=\"line\">mprotect((<span class=\"type\">void</span>*)win_addr_page, <span class=\"number\">0x2000</span>, PROT_EXEC);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进攻方\"><a href=\"#进攻方\" class=\"headerlink\" title=\"进攻方\"></a>进攻方</h2><p>题目对于进攻方的交互上没有特殊的设计，就是常规的交互。</p>\n<p>由于规则限制，所有选手需要至少提交一次flag，才能patch此题目，所以大家需要攻击默认状态下的题目，而默认状态下firewall为空，也就是简单的tcache UAF利用打IO FILE，比较基础。</p>\n<p>由于防御方依旧可以通过一些技巧，特定的限制进攻方的利用，导致利用难度剧增，本题设计了一个Level机制。</p>\n<p>本题目分成6个level，level根据防御方firewall长度而变化</p>\n<ol>\n<li><p>当firewall长度&lt;&#x3D;5 （初始情况） </p>\n<ul>\n<li>攻击方没有降低难度</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;30 (基本情况)</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;50 （基本上能检查size长度，阻止溢出了）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n<li>并且攻击方只需要在这个随机可读可写地址Addr写入win函数地址即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;80 （此时能做一点简易的uaf检查）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n<li>并且攻击方只需要在这个随机可读可写地址Addr任何非0的数值即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;120 （此时基本上能做较强的uaf检查，以及可以做一些size检查）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址</li>\n<li>并且攻击方只需要 堆上的一个位置写入win函数地址 即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;1000 （最后所有情况）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址</li>\n<li>并且攻击方只需要 堆上的一个位置写入非0 即可拿到flag</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">info</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;win: %p\\n&quot;</span>, dynamic_obj-&gt;win);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.info_leak) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> *p = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x500</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;printf: %p\\n&quot;</span>, <span class=\"built_in\">printf</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;heap: %p\\n&quot;</span>, p);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.in_heap == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;target: %p\\n&quot;</span>, dynamic_obj-&gt;near_heap_addr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">win_flag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.near_heap == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((*((<span class=\"type\">size_t</span>*)dynamic_obj-&gt;near_heap_addr)) == (<span class=\"type\">size_t</span>)dynamic_obj-&gt;win) dynamic_obj-&gt;win();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.near_heap == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*((<span class=\"type\">size_t</span>*)(dynamic_obj-&gt;near_heap_addr))) dynamic_obj-&gt;win();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _IO_flush_all();</span><br><span class=\"line\">        ___exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以进攻方，可以根据当前题目的level，进行针对性的编写exp即可。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>本题代码将在 <a href=\"https://github.com/CsomePro/9th-XCTF-Final-ADPWN\">https://github.com/CsomePro/9th-XCTF-Final-ADPWN</a> 开源，欢迎预期或非预期提交issue讨论。</p>\n","excerpt":"","more":"<h1 id=\"9th-XCTF-Final-AwD-Pwn-出题心得\"><a href=\"#9th-XCTF-Final-AwD-Pwn-出题心得\" class=\"headerlink\" title=\"9th XCTF Final AwD Pwn 出题心得\"></a>9th XCTF Final AwD Pwn 出题心得</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有幸收到Crazyman的邀请，参与了9th XCTF Final AwD赛的赛题。</p>\n<p>今年XCTF Final的赛制进行了很大的创新，除了传统的解题赛之外，还包含了RealWorld、IoT、AwD，其中AwD独占一天8.5h。对于AwD的赛制规则，今年也有大幅的改动。之前国内赛的AwD多数以AwDplus为主，少数是基于选手SSH维护服务的经典AwD，而今年的XCTF Final AwD赛制是既不会像经典AwD那样那么混乱导致选手体验失衡，也不会像AwDplus过于的束缚选手的想象力。同时XCTF Final的AwD引入了类似DEFCON的Patch和流量延迟公开的机制，使得选手对于赛制的策略需要有较大的变化。</p>\n<p>AwD的记分也有比较大的改动，为按轮次记分，被攻陷扣除30%当前得分，并平分给成功攻陷的队伍。也就是如果一支队伍一道题目很强，获得了几万分，但是如果修补存在漏洞，会导致其他队伍直接获得这几万份的30%，一举翻盘。</p>\n<p>当我收到这个赛制信息的时候是7月份，我十分喜爱这个创新，并打算构思一些有意思的题目，虽然延期了（我也10月份才动工）。最后为了适应Patch和流量延迟公开的机制以及赛题记分的机制，我贡献了两道题目somehash和someheap。</p>\n<h2 id=\"somehash\"><a href=\"#somehash\" class=\"headerlink\" title=\"somehash\"></a>somehash</h2><h3 id=\"设计构思\"><a href=\"#设计构思\" class=\"headerlink\" title=\"设计构思\"></a>设计构思</h3><p>本题是先构思的一道题目，最开始的设计是本题需要结合Crypto、Reverse的一道Pwn题。并且也不打算加入传统Pwn题打ROP、HOOK、IO FILE等技术，所以本题的核心是信息泄漏，攻击者需要思考如何从靶机中获得Admin token。</p>\n<p>首先，我设计了一个Challenge-Response挑战应答模式的登陆认证，如果认证成功，那么即可获得Shell（使用挑战应答模式可以避免其他队伍批量尝试token的时候流量造成的泄漏，以及这里也可以埋入一个漏洞点）。</p>\n<p>之后我结合Patch延迟公开的机制，设计了一个外部文件生成Admin token的过程，此过程设计上需要加入一点点的逆向，并且此处默认config是空，以及如果config校验失败也会导致Admin token为默认，其他队伍可以通过默认Admin token获得flag。</p>\n<p>由于Patch会延迟公布，所以这里要求选手，编写自动化的config生成，并且每回合都需要提交新的Patch；同理攻击者也需要编写自动化下载Patch分析config生成admin token去批量攻击其他队伍。（这同时也使得抄Patch也容易导致admin token泄漏）</p>\n<p>那么接下来，继续围绕admin token设计其他的漏洞。</p>\n<h3 id=\"漏洞清单\"><a href=\"#漏洞清单\" class=\"headerlink\" title=\"漏洞清单\"></a>漏洞清单</h3><p>题目中包含两个直接漏洞</p>\n<ol>\n<li>默认admin token以及Patch延迟公开导致admin token泄漏</li>\n<li>strncpy拼接并由printf %s泄漏admin token</li>\n</ol>\n<p>以及四个非直接的漏洞，因为涉及session中间量，所以分成两个过程，分别是 过程A和过程B</p>\n<p>过程A漏洞</p>\n<ol>\n<li>弱随机数种子 srand(time(0))</li>\n<li>利用生日攻击MD5，得到1最少的user token，通过统计泄漏的session恢复admin token</li>\n</ol>\n<p>过程B漏洞</p>\n<ol>\n<li>login逻辑中，scanf未初始化导致泄漏session</li>\n<li>show heap逻辑中，由于使用了strncpy方法导致泄漏session</li>\n</ol>\n<p>过程A中选择一种方法，过程B中选择一种方法，可以组合出4种攻击方法</p>\n<h3 id=\"修补\"><a href=\"#修补\" class=\"headerlink\" title=\"修补\"></a>修补</h3><p>这道题目依旧保留了AwDplus类似的patch elf，并check修改的字符是否在给定的允许patch范围的白名单中，本题对于ELF的patch校验十分严格，只允许4个位置，但是对于config并没有校验</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHITE_LIST = [</span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x14F1</span>, length=<span class=\"number\">0x19</span>),  <span class=\"comment\"># 修改 srand(time(0))，增强随机数</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x2057</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止login入口泄漏session</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x22cd</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止login_user拼接泄漏admin token</span></span><br><span class=\"line\">    Allowed(offset=<span class=\"number\">0x2b9c</span>, length=<span class=\"number\">5</span>),     <span class=\"comment\"># 防止堆操作泄漏session</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"直接漏洞1\"><a href=\"#直接漏洞1\" class=\"headerlink\" title=\"直接漏洞1\"></a>直接漏洞1</h4><p>默认config文件是空，<code>generate_token</code>过程中<code>memset(token, 0x41, 0x10);</code>将token初始化为0x41，config文件未反序列化成功，token仍将保持为0x41。</p>\n<p>修补建议，需要逆向config文件反序列化过程，编写自动化生成config文件与提交patch的脚本。</p>\n<h5 id=\"config生成\"><a href=\"#config生成\" class=\"headerlink\" title=\"config生成\"></a>config生成</h5><p>本题config生成是一个划分问题，题目要求将下面这个文本（随便找的0w0），划分成若干份，并按照<code>size|nonce|content</code>为一个block的方式写入文件。题目还要求block的顺序必须与与其自身的MD5顺序相同，所以需要爆破多次尝试nonce，直到符合条件（这个爆破复杂度并不大）。随后程序会根据划分的每一个block的size，拼接，计算MD5，得到admin token。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There, my blessing with thee. And these few precepts in thy memory Look thou character. Give thy thoughts no tongue, Nor any unproportioned thought his act. Be thou familiar but by no means vulgar. Those friends thou hast, and their adoption tried, Grapple them unto thy soul with hoops of steel, But do not dull thy palm with entertainment Of each new-hatched, unfledged comrade. Beware Of entrance to a quarrel, but being in, Bear &#x27;t that th&#x27; opposed may beware of thee. Give every man thy ear but few thy voice. Take each man&#x27;s censure but reserve thy judgment. Costly thy habit as thy purse can buy, But not expressed in fancy-rich, not gaudy, For the apparel oft proclaims the man, And they in France of the best rank and station Are of a most select and generous chief in that. Neither a borrower nor a lender be, For loan oft loses both itself and friend, And borrowing dulls the edge of husbandry. This above all: to thine own self be true, And it must follow, as the night the day, Thou canst not then be false to any man. Farewell. My blessing season this in thee.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>所以选手逆向理解这个逻辑之后，给大模型应该很快就能写出自动化生成的脚本。</p>\n<h4 id=\"直接漏洞2\"><a href=\"#直接漏洞2\" class=\"headerlink\" title=\"直接漏洞2\"></a>直接漏洞2</h4><p>在<code>login_user</code>逻辑中<code>strncpy(user_username, username, 0x10);</code>会填满<code>user_username</code>导致后续<code>help</code>方法泄漏admin token。</p>\n<p>修补建议，patch为<code>strncpy(user_username, username, 0xf);</code></p>\n<h4 id=\"间接漏洞-过程A-1\"><a href=\"#间接漏洞-过程A-1\" class=\"headerlink\" title=\"间接漏洞-过程A-1\"></a>间接漏洞-过程A-1</h4><p>弱随机数种子来自的<code>time(0);</code>，可能组合后续的leak session导致admin token泄漏。</p>\n<p>修补建议，使用其他数值替换srand参数，例如基于PIE的随机数种子等。</p>\n<h4 id=\"间接漏洞-过程A-2\"><a href=\"#间接漏洞-过程A-2\" class=\"headerlink\" title=\"间接漏洞-过程A-2\"></a>间接漏洞-过程A-2</h4><p>在<code>login_user</code>过程中，<code>xor_chars(user_token, tmp, 0x10);</code>存在生日攻击可能，但就算不xor也能构造出1多0少的md5，之后通过泄漏session，即可通过纵向统计session中相同位置的bit的0和1的数量即可恢复admin token。</p>\n<p><img src=\"/p/xctf-adpwnwp/111.drawio.png\" alt=\"111.drawio\"></p>\n<p>此漏洞为逻辑漏洞，无法修补，建议修补其他泄漏session的过程</p>\n<h4 id=\"间接漏洞-过程B-1\"><a href=\"#间接漏洞-过程B-1\" class=\"headerlink\" title=\"间接漏洞-过程B-1\"></a>间接漏洞-过程B-1</h4><p>在login函数中，<code>scanf(&quot;%lx&quot;, &amp;chall-&gt;session.a);</code>可能导致<code>chall-&gt;session.a</code>未初始化问题，导致堆上数据泄露，从而可以组合过程A，泄漏admin token。</p>\n<p>修补建议，将生成challenge的函数rand_bytes参数增加<code>rand_bytes((unsigned char*)chall-&gt;challenge, 0x20);</code></p>\n<h4 id=\"间接漏洞-过程B-2\"><a href=\"#间接漏洞-过程B-2\" class=\"headerlink\" title=\"间接漏洞-过程B-2\"></a>间接漏洞-过程B-2</h4><p>在view_note的函数中，<code>strncpy(tmp, buffer[idx], sizes[idx]);</code>此处使用strncpy拷贝堆上xor后的数据，而堆上数据可能会因为0截断，导致拷贝并不完全，导致tmp数据缺失部分数据，最后进行decrypt的时候泄漏session</p>\n<p>修补建议，将<code>strncpy</code>替换成<code>memcpy</code>即可。</p>\n<h2 id=\"someheap\"><a href=\"#someheap\" class=\"headerlink\" title=\"someheap\"></a>someheap</h2><p>本题是在XCTF比赛前一周开始构思的题目，一样需要结合XCTF Final的Patch公开机制和流量公开机制，打算设计一个竞技性很强的题目。本题也是打算设计成比较贴近DEFCON Final题目的类型，让选手体验竞技的刺激。</p>\n<p>（其实也是不想写传统的白名单限制允许patch的区域，这种模式有点像是填空题了，所以这道题目设计上不希望选手能patch ELF了）</p>\n<p>这道题目核心是一道堆菜单题，并且需要利用好防御方和攻击方的作用。</p>\n<p>这道菜单题，包含多个堆原语的操作。</p>\n<ol>\n<li>Add操作 （分成malloc和calloc）</li>\n<li>Free操作 （存在UAF）</li>\n<li>Edit操作 （写入长度由攻击方控制，可以overflow）</li>\n<li>Show操作 （输出长度由攻击方控制，越界泄漏）</li>\n</ol>\n<h2 id=\"防御方\"><a href=\"#防御方\" class=\"headerlink\" title=\"防御方\"></a>防御方</h2><p>本题设计的难点主要在于防御方。为了能更好的融入题目，这里设计了一个firewall文件，防御方需要编写amd64的机器码，当程序启动的时候，会加载这个firewall文件到内存中，随后在堆操作前后会调用这个文件，进行check（check返回约定是，返回0表示正常，返回非0程序将exit退出）</p>\n<p>由于防御方拥有当前进程执行任意代码的能力，所以我需要给防御方增加编写amd64代码的难度。</p>\n<ol>\n<li><p>首先这道题目开启了沙箱，并且firewall不允许包含<code>0x0f 0x05</code> syscall&#x2F;<code>0x0f 0x34</code> sysenter&#x2F;<code>0xcd 0x80</code> int 0x80这些会产生系统调用的指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># check if arch is X86_64</span><br><span class=\"line\">A = arch</span><br><span class=\"line\">A == ARCH_X86_64 ? next : dead</span><br><span class=\"line\">A = sys_number</span><br><span class=\"line\">A &gt;= 0x40000000 ? dead : next</span><br><span class=\"line\">A == open ? ok : next</span><br><span class=\"line\">A == read ? ok : next</span><br><span class=\"line\">A == write ? ok : next</span><br><span class=\"line\">A == close ? ok : next</span><br><span class=\"line\">A == brk ? ok : next</span><br><span class=\"line\">A == exit ? ok : next</span><br><span class=\"line\">A == exit_group ? ok : next</span><br><span class=\"line\">A == futex ? ok : next</span><br><span class=\"line\">A == getrandom ? ok : next</span><br><span class=\"line\">if(A == arch_prctl) goto prctl_test</span><br><span class=\"line\">goto dead</span><br><span class=\"line\">prctl_test:</span><br><span class=\"line\">A = args[0]</span><br><span class=\"line\">A == 0x1001 ? ok : next</span><br><span class=\"line\">A == 0x1002 ? ok : next</span><br><span class=\"line\">A == 0x1003 ? ok : next</span><br><span class=\"line\">A == 0x1004 ? ok : next</span><br><span class=\"line\">goto dead</span><br><span class=\"line\">ok:</span><br><span class=\"line\">return ALLOW</span><br><span class=\"line\">dead:</span><br><span class=\"line\">return KILL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了防止防御者可以通过地址计算，逃逸到bss上，或者libc中，这里需要防止防御者使用代码计算得到bss&#x2F;libc地址，所以这里采用了强随机地址，使用<code>/dev/urandom</code>生成强随机的地址区域，作为firewall代码段、firewall执行的stack空间等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dynamic_obj-&gt;func =  mmap((<span class=\"type\">void</span>*)((<span class=\"type\">size_t</span>)get_random_addr() &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">dynamic_obj-&gt;<span class=\"built_in\">stack</span> = mmap((<span class=\"type\">void</span>*)((<span class=\"type\">size_t</span>)get_random_addr() &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x1000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其次执行firewall的时候需要清空所有寄存器包括xmm寄存器和fs、gs寄存器，但是由于需要记录返回地址，所以我将返回地址记录在了firewall代码段的最后方，此时又需要防止firewall读取到这个地址导致逃逸，所以我设置了firewall代码段<code>--x</code>的权限</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mprotect(dynamic_obj-&gt;func, <span class=\"number\">0x1000</span>, PROT_EXEC);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了让firewall程序编程无状态的，所以每次执行的时候都会将firewall执行栈清空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">memset</span>(dynamic_obj-&gt;<span class=\"built_in\">stack</span>, <span class=\"number\">0</span>, <span class=\"number\">0x1000</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后为了防止防御方很简单的通过idx信息进行记录对应的堆状态，这里允许攻击者设置srand种子，并且firewall获得idx参数时解密前的参数，真实idx是<code>encrypt(idx) % 0x100</code> (这里为了rand()数据在stack上残留，故意开了O2)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__attribute__((optimize(<span class=\"string\">&quot;O2&quot;</span>))) <span class=\"type\">size_t</span> <span class=\"title function_\">encrypt</span><span class=\"params\">(<span class=\"type\">size_t</span> val)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">register</span> <span class=\"type\">size_t</span> rand_val = (<span class=\"type\">size_t</span>)rand();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val + rand_val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后防御方还有一个最困难的一点，防御方无法判断当前被调用的地方是在add&#x2F;free&#x2F;show&#x2F;edit哪一个功能中，因为每一个传入的参数都是<code>(idx, size, heap_addr)</code></p>\n</li>\n</ol>\n<p>这些大概就是防御方的限制，可以看到，防御方只能通过一些堆的状态进行判断。</p>\n<p>比较好的是，进行校验的位置都是堆地址申请出来之后，释放之前这个区间进行校验，也就是说，堆地址正常生命周期处在被使用的时候会进入check，所以最简单的校验是通过<code>prev_inuse</code>位置来判断，当前堆地址是否存在UAF问题。（当然这也只能解决unsortedbins、smallbins、largebins这些相关的UAF，并不能解决fastbins、tcachebins的UAF问题）</p>\n<p>其次，为了解决Overflow的问题，也可以通过获取堆的size，进行判断。这两个校验应该是比较容易想到的。</p>\n<p><strong>如何解决tcachebins的UAF问题？</strong></p>\n<p>我也没想到很完备的方案能解决这个问题，但是可以稍微限制的是，可以通过解析<code>tcache_entry</code>结构体，来校验是否存在tcache UAF问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stddef.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> TCACHE_MAX_BINS\t\t64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_entry</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_entry</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* This field exists to detect double frees.  */</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> key;</span><br><span class=\"line\">&#125; tcache_entry;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">short</span> counts[TCACHE_MAX_BINS];</span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">size_t</span> a, <span class=\"type\">size_t</span> b, <span class=\"type\">size_t</span> addr)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> base = addr &amp; (~<span class=\"number\">0xfff</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">size_t</span>* p = (<span class=\"type\">size_t</span>*)(base + <span class=\"number\">0x8</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*p != <span class=\"number\">0x291</span>) &#123;</span><br><span class=\"line\">            base -= <span class=\"number\">0x1000</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tcache_perthread_struct* tcache = (tcache_perthread_struct*)(base + <span class=\"number\">0x10</span>);</span><br><span class=\"line\">    <span class=\"type\">size_t</span> size = *(<span class=\"type\">size_t</span>*)(addr - <span class=\"number\">0x8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size &gt; <span class=\"number\">0x410</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">size_t</span> tc_idx = (size - <span class=\"number\">0x20</span>) &gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> tc_cnt = tcache-&gt;counts[tc_idx];</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    tcache_entry *tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class=\"line\">         tmp;</span><br><span class=\"line\">         tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt &gt;= tc_cnt) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"type\">size_t</span>)tmp == addr) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这个检查也有机会绕过，通过在页对齐的地方布置一个伪造的<code>tcache_entry</code>即可。</p>\n<p><strong>后门？</strong></p>\n<p>在比赛的开始也给了提示，这道题目后门是允许的预期。虽然我在后台看日志的时候没找到后门的样本，如果有遗漏，欢迎大家评论或者提交issue！</p>\n<p>这里给一个预期中的后门设计方法。</p>\n<p>由于这道题目firewall的限制非常大，在一个构造的沙箱中，我们可以通过一些特征的size或者heap内容特定的字符串，或者是heap特定的size等等，这些进行校验是否进入后门分支。其次，由于需要逃逸沙箱，所以需要保证堆数据中包含libc地址，比如说main_arena地址，之后firewall就可以从main_arena逃逸到_environ，逃逸到stack上，stack上包含程序的基地址，从而计算出bss地址，最后即可得到<code>dynamic_obj</code>中所有的信息，其中包含了win函数的地址，直接jmp到win，即可获得flag。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> win[] = &#123; <span class=\"number\">0x48</span>, <span class=\"number\">0xb8</span>, <span class=\"number\">0x2f</span>, <span class=\"number\">0x66</span>, <span class=\"number\">0x6c</span>, <span class=\"number\">0x61</span>, <span class=\"number\">0x67</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x50</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe7</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc6</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x02</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc2</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x89</span>, <span class=\"number\">0xe6</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc2</span>, <span class=\"number\">0x40</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x01</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0xc7</span>, <span class=\"number\">0xc0</span>, <span class=\"number\">0x3c</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x48</span>, <span class=\"number\">0x31</span>, <span class=\"number\">0xff</span>, <span class=\"number\">0x0f</span>, <span class=\"number\">0x05</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">size_t</span> win_addr = (<span class=\"type\">size_t</span>)get_random_addr();</span><br><span class=\"line\">dynamic_obj-&gt;win =  mmap((<span class=\"type\">void</span>*)(win_addr &amp; (~<span class=\"number\">0xfff</span>)), <span class=\"number\">0x2000</span>, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class=\"number\">-1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"type\">size_t</span> win_addr_page = (<span class=\"type\">size_t</span>)dynamic_obj-&gt;win;</span><br><span class=\"line\">dynamic_obj-&gt;win = (<span class=\"type\">void</span>*)(((<span class=\"type\">size_t</span>)dynamic_obj-&gt;win) + (win_addr &amp; <span class=\"number\">0xfff</span>));</span><br><span class=\"line\"><span class=\"built_in\">memcpy</span>(dynamic_obj-&gt;win, win, <span class=\"keyword\">sizeof</span>(win));</span><br><span class=\"line\">mprotect((<span class=\"type\">void</span>*)win_addr_page, <span class=\"number\">0x2000</span>, PROT_EXEC);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进攻方\"><a href=\"#进攻方\" class=\"headerlink\" title=\"进攻方\"></a>进攻方</h2><p>题目对于进攻方的交互上没有特殊的设计，就是常规的交互。</p>\n<p>由于规则限制，所有选手需要至少提交一次flag，才能patch此题目，所以大家需要攻击默认状态下的题目，而默认状态下firewall为空，也就是简单的tcache UAF利用打IO FILE，比较基础。</p>\n<p>由于防御方依旧可以通过一些技巧，特定的限制进攻方的利用，导致利用难度剧增，本题设计了一个Level机制。</p>\n<p>本题目分成6个level，level根据防御方firewall长度而变化</p>\n<ol>\n<li><p>当firewall长度&lt;&#x3D;5 （初始情况） </p>\n<ul>\n<li>攻击方没有降低难度</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;30 (基本情况)</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;50 （基本上能检查size长度，阻止溢出了）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n<li>并且攻击方只需要在这个随机可读可写地址Addr写入win函数地址即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;80 （此时能做一点简易的uaf检查）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址、一个随机可读可写地址Addr</li>\n<li>并且攻击方只需要在这个随机可读可写地址Addr任何非0的数值即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;120 （此时基本上能做较强的uaf检查，以及可以做一些size检查）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址</li>\n<li>并且攻击方只需要 堆上的一个位置写入win函数地址 即可拿到flag</li>\n</ul>\n</li>\n<li><p>当firewall长度&lt;&#x3D;1000 （最后所有情况）</p>\n<ul>\n<li>攻击方能直接获得heap地址、libc地址</li>\n<li>并且攻击方只需要 堆上的一个位置写入非0 即可拿到flag</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">info</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;win: %p\\n&quot;</span>, dynamic_obj-&gt;win);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.info_leak) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> *p = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x500</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;printf: %p\\n&quot;</span>, <span class=\"built_in\">printf</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;heap: %p\\n&quot;</span>, p);</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.in_heap == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;target: %p\\n&quot;</span>, dynamic_obj-&gt;near_heap_addr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">win_flag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.near_heap == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((*((<span class=\"type\">size_t</span>*)dynamic_obj-&gt;near_heap_addr)) == (<span class=\"type\">size_t</span>)dynamic_obj-&gt;win) dynamic_obj-&gt;win();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dynamic_obj-&gt;level.near_heap == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(*((<span class=\"type\">size_t</span>*)(dynamic_obj-&gt;near_heap_addr))) dynamic_obj-&gt;win();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        _IO_flush_all();</span><br><span class=\"line\">        ___exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以进攻方，可以根据当前题目的level，进行针对性的编写exp即可。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>本题代码将在 <a href=\"https://github.com/CsomePro/9th-XCTF-Final-ADPWN\">https://github.com/CsomePro/9th-XCTF-Final-ADPWN</a> 开源，欢迎预期或非预期提交issue讨论。</p>\n","path":"/p/xctf-adpwnwp/","permalink":"https://blog.csome.cc/p/xctf-adpwnwp/","tags":[{"name":"CTF","_id":"cuido_V8Oh2SS0Zh3psZIuqJ6","slug":"CTF","path":"tags/CTF/","permalink":"https://blog.csome.cc/tags/CTF/","length":16},{"name":"Pwn","_id":"cuidf9SJlBoYLN5swxTldfoFK","slug":"Pwn","path":"tags/Pwn/","permalink":"https://blog.csome.cc/tags/Pwn/","length":16},{"name":"wp","_id":"cuidDebPEsrJYiQfuo75QOEu3","slug":"wp","path":"tags/wp/","permalink":"https://blog.csome.cc/tags/wp/","length":2},{"name":"XCTF","_id":"cuidc4PrrjKDZskaTyH5jCXbd","slug":"XCTF","path":"tags/XCTF/","permalink":"https://blog.csome.cc/tags/XCTF/","length":1}],"categories":[],"prev":null,"next":{"title":"[2024长城杯初赛] Pwn题SomeHash SomeTime shutup题解","date":"2024-03-31T12:46:11.000Z","slug":"2024changchengbei","published":true,"updated":"2025-10-28T08:00:40.753Z","_id":"cuidNicVEGsayCw4xoXcfstEI","layout":"post","photos":[],"excerpt":"","path":"/p/2024changchengbei/","permalink":"https://blog.csome.cc/p/2024changchengbei/","__post":true},"__post":true}